<!DOCTYPE HTML>
<!--
	Read Only by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)

	Modified by Alex Fern√°ndez
	https://pinchito.es/ | @pinchito
-->
<html>
	<head>
		<title>Modo cluster para node.js</title>
		<meta charset="utf-8" />
		<meta name="description" content="Modo cluster para node.js ‚Äî " />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@pinchito" />
		<meta name="twitter:title" content="Modo cluster para node.js ‚Äî " />
		<meta name="twitter:description" content="" />
		<meta name="twitter:image" content="" />
		<meta property="og:title" content="Modo cluster para node.js ‚Äî " />
		<meta property="og:type" content="website" />
		<meta property="og:description" content="" />
		<meta property="og:image" content="" />
		<meta property="og:url" content="https://pinchito.es/2013/modo-cluster" />
		<link rel="stylesheet" href="/css/main.css" />
		<link rel="canonical" href="https://pinchito.es/2013/modo-cluster" />
		<link rel="shortcut icon" href="/favicon.png" type="image/png" />
		<!--[if lte IE 8]><link rel="stylesheet" href="/css/ie8.css" /><![endif]-->
	</head>
	<body>

		<!-- Header -->
			<section id="header">
				<header>
					<p class="home"><a class="home" href="/">pinchito.es</a></p>
					<p>
					<a href="/about">about</a>
					<br/>
					<a href="/cv">CV</a>
					<br/>
					<a href="/rss.xml">
						<svg aria-hidden="true" class="rss-icon" width="18" height="18" viewBox="0 0 18 18"><path d="M3 1a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2zm0 1.5c6.9 0 12.5 5.6 12.5 12.5H13C13 9.55 8.45 5 3 5zm0 5c4.09 0 7.5 3.41 7.5 7.5H8c0-2.72-2.28-5-5-5zm0 5c1.36 0 2.5 1.14 2.5 2.5H3z"></path></svg>
						RSS feed</a>
					</p>
					<p>
					<a href="https://bsky.app/profile/pinchito.bsky.social" target="_blank">ü¶ã @pinchito.bsky.social</a>
					<br />
					<a rel="me" href="https://mastodon.social/@pinchito" target="_blank">üêò @pinchito@mastodon.social</a>
					<br/>
					<a href="https://github.com/alexfernandez" aria-label="Follow @alexfernandez on GitHub">alexfernandez @ GitHub</a>
					</p>
					<p>
					This site is cookie free! No tracking is done on your browser.
					</p>
					<a href="https://librecounter.org/referer/show" target="_blank">
					<img src="https://librecounter.org/counter.svg" referrerPolicy="unsafe-url">
					</a>
				</header>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<section id="zero">
							<p class="home"><a class="home" href="/">pinchito.es</a></p>
						</section>

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h1>Modo cluster para node.js</h1>
										<p><p>
									</header>
																				<figure>
<img src="pics/modo-cluster.jpg"
title="VST image of the Hercules galaxy cluster"
alt="Imagen: OmegaCen/Astro-WISE/Kapteyn Institute" />
<figcaption aria-hidden="true">Imagen: <a
href="https://commons.wikimedia.org/wiki/File:VST_image_of_the_Hercules_galaxy_cluster.jpg">OmegaCen/Astro-WISE/Kapteyn
Institute</a></figcaption>
</figure>
<p>¬øQuieres habilitar el modo cluster en node.js? En este art√≠culo
veremos c√≥mo, completo con c√≥digo y detalles.</p>
<h2 id="por-qu√©-necesito-el-modo-cluster">¬øPor qu√© necesito el modo
cluster?</h2>
<p>El funcionamiento normal de node.js es en modo mono-procesador: un
hilo de ejecuci√≥n, un solo proceso. Lo de tener un hilo es la esencia de
node.js: en lugar de correr varios hilos o <em>threads</em>, usamos el
procesamiento as√≠ncrono para procesar m√∫ltiples peticiones a la vez. Por
otra parte, tener un solo proceso puede ser una limitaci√≥n muy
grande.</p>
<p>Hoy en d√≠a los procesadores multi-n√∫cleo han dejado de ser la joya de
los datacenters para convertirse en algo rutinario: es normal llevar en
la mochila un dispositivo con dos n√∫cleos o cores, y a menudo otro en
los bolsillos. En Amazon AWS se pueden alquilar servidores con 8 CPUs
virtuales por unos ‚Ç¨350/mes (<a
href="http://aws.amazon.com/es/ec2/pricing/">precios</a> de <a
href="http://www.xe.com/currencyconverter/convert/?Amount=475&amp;From=USD&amp;To=EUR">hoy</a>).
Pr√°cticamente cualquier cosa m√°s grande que una Raspberry Pi tiene m√°s
de un n√∫cleo. Sin embargo, nuestro node.js por defecto corre como un
√∫nico proceso en el servidor, usando un √∫nico <em>core</em> o
procesador. ¬øC√≥mo podemos dejar de desaprovechar el 50% (o el 87.5%) de
estas m√°quinas?</p>
<h2 id="activando-el-modo-cluster">Activando el modo cluster</h2>
<p>Node tiene un <a href="http://nodejs.org/api/cluster.html">API de
cluster</a> bastante completo. A d√≠a de hoy (v0.10.5), el API est√°
marcado como <code>Stability: 1 - Experimental</code>. Esto puede echar
para atr√°s a cualquiera que necesite usarlo en producci√≥n.</p>
<p>Para los valientes, hay que decir que este API est√° presente desde la
<a href="http://nodejs.org/docs/v0.6.19/api/cluster.html">versi√≥n
v0.6.x</a>, y funciona de forma robusta desde la <a
href="http://nodejs.org/docs/v0.8.19/api/cluster.html">versi√≥n
v0.8.x</a> al menos. Marcarlo como experimental permite a los
desarrolladores hacer cambios entre versiones sin tener que dar
explicaciones. As√≠ que cuidado con cambios futuros; como siempre, hay
que hacer <a href="pruebas-asincronas.html">pruebas exhaustivas</a>
antes de desplegar una nueva versi√≥n de node.js.</p>
<h3 id="maestro-y-trabajadores">Maestro y trabajadores</h3>
<p>Uno de los secretos a voces de node.js es que adopta muchos
principios de Unix, llev√°ndolos a su propio terreno. En este caso la
creaci√≥n de procesos es muy similar al modelo de Unix: un sencillo <a
href="http://en.wikipedia.org/wiki/Fork_(operating_system)"><code>fork()</code></a>
crea una copia del proceso actual. A partir de ese momento el primer
proceso se convierte en maestro o master, y la copia en un trabajador o
<em>worker</em>. Es similar a c√≥mo funcionan nginx o Apache, y a otros
programas multi-proceso Linux.</p>
<h3 id="al-turr√≥n">Al turr√≥n</h3>
<p>Vamos a ver el c√≥digo necesario para usar el modo cluster. El ejemplo
que vamos a comentar est√° sacado directamente de la <a
href="http://nodejs.org/api/cluster.html#cluster_cluster">documentaci√≥n
de node.js</a>, con m√≠nimas adaptaciones: un servidor HTTP que devuelve
siempre la cadena <code>hola, mundo</code>.</p>
<p>Primero un par de requires, uno para cluster y otro para el servidor
HTTP:</p>
<pre><code>var cluster = require(&#39;cluster&#39;);
var http = require(&#39;http&#39;);</code></pre>
<p>Crearemos tantos workers como CPUs tengamos en el sistema:</p>
<pre><code>var numCPUs = require(&#39;os&#39;).cpus().length;</code></pre>
<p>Es habitual hacer que el proceso master se dedique √∫nicamente a
gestionar a los workers, y que sean los workers los que hagan el trabajo
sucio. El patr√≥n es siempre el mismo:</p>
<pre><code>if (cluster.isMaster)
{
  // crea workers
}
else
{
  // abre el servidor
}</code></pre>
<p>Primero creamos los workers en el proceso maestro:</p>
<pre><code>if (cluster.isMaster)
{
  // crea workers, uno por CPU
  for (var i = 0; i &lt; numCPUs; i++)
  {
    cluster.fork();
  }</code></pre>
<p>Ahora controlamos la salida de los workers:</p>
<pre><code>  cluster.on(&#39;exit&#39;, function(worker, code, signal)
  {
    console.log(&#39;worker &#39; + worker.process.pid + &#39; died&#39;);
  });
}</code></pre>
<p>Eso es todo lo que tiene que hacer el master. En los workers (es
decir, <code>cluster.isMaster</code> es falso) creamos un servidor
HTTP:</p>
<pre><code>else
{
  // crea un servidor HTTP
  http.createServer(function(req, res)
  {
    res.writeHead(200);
    res.end(&quot;hola, mundo\n&quot;);
  }).listen(8000);
}</code></pre>
<p>¬°Y listo! El c√≥digo real que usamos en MediaSmart Mobile es muy
similar a √©ste: poco m√°s hace falta para poner un servidor en
producci√≥n. En el resto de este art√≠culo vamos a ver otros detalles que
pueden ser √∫tiles.</p>
<h2 id="conexiones-compartidas">Conexiones compartidas</h2>
<p>El modo de uso m√°s popular de node.js es como servidor: ponerlo a
escuchar por un puerto y responder peticiones. ¬øC√≥mo podemos conseguir
que varios workers escuchen por el mismo puerto? ¬øTendremos que hacer
que el proceso master reciba las peticiones y las despache a los workers
usando alg√∫n algoritmo ingenioso?</p>
<p>Un momento: el c√≥digo que acabamos de ver crea un servidor por cada
worker directamente, sin pararse a pensar. Vamos a verlo otra vez en
contexto:</p>
<pre><code>if (cluster.isWorker)
{
  // crea un servidor HTTP
  http.createServer(function(req, res)
  {
    res.writeHead(200);
    res.end(&quot;hola mundo\n&quot;);
  }).listen(8000);
}</code></pre>
<p>¬øAcaso el cluster se encarga de hacer el reparto? La realidad es
mucho mejor: el propio core de node.js va a hacer para nosotros el
trabajo duro. Si varios workers comparten una conexi√≥n TCP, repartir√°
las peticiones entrantes entre los procesos que escuchan por el mismo
puerto. Nosotros no tenemos nada que hacer: es una de las cosas que m√°s
nos gustan del modo cluster.</p>
<p>El algoritmo que usa no es <em>round robin</em>, o sea un reparto
equitativo entre procesos. M√°s bien se tiende a cargar m√°s unos cuantos
procesos, dejando el resto m√°s libres. Un servidor de producci√≥n con
varios procesos de node y carga media tiene esta pinta:</p>
<pre><code>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+ COMMAND
 6633 dilbert   20   0  824m 123m 6284 S   77  1.8   2:11.64 node
 6764 dilbert   20   0  810m 129m 6276 S   76  1.9   0:32.71 node
 6429 dilbert   20   0  885m 111m 6284 S   70  1.6   2:49.19 node
 6696 dilbert   20   0  813m 127m 6284 R   69  1.8   1:24.06 node
 6148 dilbert   20   0  894m 114m 6284 R   59  1.6   4:36.41 node
 6362 dilbert   20   0  892m 109m 6284 R   57  1.6   3:23.42 node
 6233 dilbert   20   0  900m 151m 6296 R   51  2.2   4:22.03 node
 6297 dilbert   20   0  898m 150m 6296 S   40  2.2   3:53.95 node</code></pre>
<h2 id="supervisi√≥n-de-trabajadores">Supervisi√≥n de trabajadores</h2>
<p>Una t√©cnica √∫til es hacer que el master siga la pista de cu√°ndo se
mueren los workers, por ejemplo por errores imprevistos, para crear m√°s.
El c√≥digo de la <a
href="http://nodejs.org/api/cluster.html#cluster_event_exit">documentaci√≥n</a>
es muy elocuente:</p>
<pre><code>cluster.on(&#39;exit&#39;, function(worker, code, signal)
{
  console.log(&#39;Se ha muerto el worker %s, reiniciando&#39;, worker.process.pid);
  cluster.fork();
});</code></pre>
<p>Una t√©cnica interesante es matar directamente los workers despu√©s de
un tiempo determinado, y recrearlos con un nuevo <code>fork()</code>. De
esta forma evitamos que peque√±as filtraciones de memoria o memory leaks
afecten a la ejecuci√≥n de nuestro servidor. No es broma; IBM llam√≥ a
esta t√©cnica <a
href="http://domino.research.ibm.com/tchjr/journalindex.nsf/9fe6a820aae67ad785256547004d8af0/e27eaf128f579c2b85256bfa0067fade!OpenDocument">rejuvenation</a>
hace unos a√±os, y la usa en sus servidores de gama alta. En otros
√°mbitos podr√≠a considerarse una mera chapuza para evitar arreglar fallos
escandalosos; en cualquier caso no vamos a ver el c√≥digo concreto aqu√≠,
pero con la documentaci√≥n deber√≠a bastar para saber c√≥mo hacerlo.</p>
<p>El lector avispado se habr√° dado cuenta de que, pese a nuestro
cuidado por replicar los procesos, hemos introducido un punto √∫nico de
fallo: si el proceso master se muere, todo nuestro tinglado se derrumba
porque nadie va a poder recrearlo. Por eso, trabajar en modo cluster no
quita que sigamos usando alg√∫n tipo de gesti√≥n de procesos que levante
nuestro proceso maestro si se cae: <a
href="https://github.com/isaacs/node-supervisor">supervisor</a> y <a
href="https://github.com/nodejitsu/forever">forever</a> son dos m√≥dulos
de node muy √∫tiles, y en Linux podemos usar la gesti√≥n nativa de
procesos, systemd o Upstart. Porque est√°bamos usando ya alg√∫n tipo de
gesti√≥n de procesos, ¬øverdad? ¬øVerdad?</p>
<p>Bueno, pues si no es as√≠, ahora es buen momento para mirar las
posibilidades.</p>
<h2 id="mensajes-internos">Mensajes internos</h2>
<p>¬øQu√© podemos hacer si queremos agregar informaci√≥n entre todos los
workers? Un caso de uso t√≠pico es cuando queremos sacar estad√≠sticas
globales de cu√°ntas peticiones hemos servido por minuto. En modo cluster
no nos vale con guardar los resultados en memoria y pintarlos de vez en
cuando: hay que agregar la informaci√≥n entre todos los procesos worker
que ahora tenemos andando. En primer lugar, esta funci√≥n env√≠a al master
la informaci√≥n de la variable <code>stats</code> usando
<code>process.send()</code>:</p>
<pre><code>function sendStats(stats)
{
  var message = { stats: stats };
  process.send(message);
}</code></pre>
<p>En el master queremos recoger los mensajes enviados por los workers y
a√±adir las estad√≠sticas a la variable <code>globalStats</code>. Tenemos
que llamar al worker resultado del <code>fork()</code> <a
href="http://nodejs.org/api/cluster.html#cluster_event_message">de esta
forma</a>:</p>
<pre><code>var worker = cluster.fork();
worker.on(&#39;message&#39;, function(message)
{
  globalStats += message.stats;
});</code></pre>
<p>Si queremos recibir mensajes de varios tipos, s√≥lo tenemos que a√±adir
un atributo <code>message.type</code> con el tipo de mensaje, y luego
discriminar al recibirlo.</p>
<p>Los workers tambi√©n pueden recibir mensajes del master, usando
exactamente la misma API. Nunca vamos a poder compartir memoria, pero s√≠
objetos aleatorios que ser√°n serializados y recibidos.</p>
<h2 id="servidor-stateless">Servidor stateless</h2>
<p>Para usar el modo cluster apropiadamente tenemos que asegurarnos de
que nuestro servidor sea (<em>atenci√≥n, palabro</em>)
<em>stateless</em>: que no mantenga el estado de las peticiones en
memoria.</p>
<p>Un servidor stateless es siempre una buena pr√°ctica, por ejemplo si
tenemos varios frontends sirviendo peticiones. Supongamos que creamos
una cookie o un token de acceso para cada usuario que entra, y lo usamos
para identificar sus peticiones. Si guardamos la lista de tokens en
memoria, y la siguiente petici√≥n del mismo usuario llega a otro
frontend, estamos perdidos: no tenemos forma de reconocer al
usuario.</p>
<p>Lo mismo vale para el modo cluster, que a todos los efectos es como
si tuvi√©ramos varios servidores independientes. Todo dato necesario para
el servidor debe estar almacenado en base de datos o alg√∫n otro tipo de
almacenamiento compartido ‚Äî un memcached es una buena elecci√≥n para
datos vol√°tiles.</p>
<h3 id="un-servidor-cluster-y-stateful">¬øUn servidor cluster y
<em>stateful</em>?</h3>
<p>En modo cluster existe una alternativa al servidor stateless:
compartir la informaci√≥n a trav√©s del master. Cuando cada worker crea un
token, tiene que informar al master, que a su vez informar√° a todos los
dem√°s workers para que actualicen sus listas de tokens v√°lidos. Y lo
mismo cuando se invalida un token. Es una aplicaci√≥n interesante de la
mensajer√≠a que dejamos como ejercicio al lector.</p>
<p>Para uso pr√°ctico, podemos ver que la complejidad empieza a aumentar
m√°s all√° de lo razonable. Adem√°s esta soluci√≥n no es v√°lida para
m√∫ltiples frontends. La recomendaci√≥n de este desarrollador es (siempre
que sea posible) el servidor stateless.</p>
<h2 id="conclusi√≥n">Conclusi√≥n</h2>
<p>El modo cluster es una herramienta esencial para poner node.js en
producci√≥n. No te dejes atemorizar por el API experimental o por la
aparente complejidad del problema; node.js hace que tener m√∫ltiples
procesos sea casi tan f√°cil como tener uno solo.</p>
								</div>
							</section>
							<section id="last">
								<div class="container">
									<p>
									Original publicado en <a
href="http://www.godtic.com/blog/2013/07/27/modo-cluster-para-node-js/">GodTIC</a>
el 2013-07-27.
									</p>
									<p>
									Back to the <a href="/">index</a>.
									</p>
								</div>
							</section>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<ul class="copyright">
								<li>
									¬© <a href="mailto:alexfernandeznpm@gmail.com">Alex Fern√°ndez</a>.
									<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
								</li>
								<li>Original design: <a href="http://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</section>

			</div>
	</body>
</html>
