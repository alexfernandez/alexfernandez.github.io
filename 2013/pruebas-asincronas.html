<!DOCTYPE HTML>
<!--
	Read Only by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)

	Modified by Alex Fern√°ndez
	https://pinchito.es/ | @pinchito
-->
<html>
	<head>
		<title>Pruebas as√≠ncronas en node.js</title>
		<meta charset="utf-8" />
		<meta name="description" content="Pruebas as√≠ncronas en node.js ‚Äî " />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@pinchito" />
		<meta name="twitter:title" content="Pruebas as√≠ncronas en node.js ‚Äî " />
		<meta name="twitter:description" content="" />
		<meta name="twitter:image" content="" />
		<link rel="stylesheet" href="/css/main.css" />
		<link rel="canonical" href="https://pinchito.es/2013/pruebas-asincronas" />
		<link rel="shortcut icon" href="/favicon.png" type="image/png" />
		<!--[if lte IE 8]><link rel="stylesheet" href="/css/ie8.css" /><![endif]-->
	</head>
	<body>

		<!-- Header -->
			<section id="header">
				<header>
					<p class="home"><a class="home" href="/">pinchito.es</a></p>
					<p>
					<a href="/about">about</a>
					<br/>
					<a href="/cv">CV</a>
					<br/>
					<a href="/speaker">speaker</a>
					</p>
					<p>
					<a id="follower" href="https://twitter.com/intent/follow?screen_name=pinchito" target="_blank"><i id="birdie"></i>@pinchito</a>
					<br />
					<a rel="me" href="https://mastodon.social/@pinchito" target="_blank">üêò @pinchito@mastodon.social</a>
					<br/>
					<a href="https://github.com/alexfernandez" aria-label="Follow @alexfernandez on GitHub">alexfernandez @ GitHub</a>
					<br/>
					<a href="https://www.youtube.com/channel/UCp5fMWhuqcbrvSJEOByeGwg">YouTube</a>
					</p>
					<p>
					This site is cookie free! No tracking is done on your browser.
					</p>
				</header>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<section id="zero">
							<p class="home"><a class="home" href="/">pinchito.es</a></p>
						</section>

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h1>Pruebas as√≠ncronas en node.js</h1>
										<p><p>
									</header>
																				<figure>
                    <img src="pics/pruebas-asincronas.jpg" title="Filas de t√©cnicos en uniforme as√©ptico miran en microscopios." alt="" /><figcaption>Laboratorio de pruebas.</figcaption>
                    </figure>
                    <p>node.js est√° muy orientado al desarrollo de software as√≠ncrono: en lugar de ejecutar c√≥digo y mantenernos ocupados mientras llega la respuesta, se suele liberar el hilo de ejecuci√≥n para que corran otras tareas mientras esperamos.</p>
                    <p>Las pruebas as√≠ncronas suelen ser bastante complejas: primero hay que hacer una llamada, esperar, y luego comprobar que el resultado devuelto es el esperado. En este post (mi primero en este blog) explicar√© c√≥mo usar una nueva librer√≠a de pruebas (llamada, en un alarde de imaginaci√≥n, testing) pensada especialmente para facilitar pruebas as√≠ncronas.</p>
                    <h2 id="instalaci√≥n">Instalaci√≥n</h2>
                    <p>Para instalar la librer√≠a s√≥lo tenemos que hacer en el directorio ra√≠z:</p>
                    <pre><code>$ npm install testing</code></pre>
                    <p>O a√±adir testing a las dependencias en nuestro <code>package.json</code>. A continuaci√≥n podemos empezar a jugar con la librer√≠a.</p>
                    <h2 id="pruebas-elementales">Pruebas elementales</h2>
                    <p>Las pruebas m√°s sencillas son las que no necesitan esperar a ning√∫n evento. El esquema es siempre el mismo: corremos nuestro c√≥digo con unos par√°metros preparados, comprobamos los resultados y declaramos el √©xito o el fracaso de la prueba. Vamos a ver el t√≠pico ejemplo de la funci√≥n que suma:</p>
                    <pre><code>function sum(first, second)
                    {
                      return first + second;
                    }</code></pre>
                    <p>La probamos pas√°ndole par√°metros conocidos (por ejemplo 1 y 1), y verificando que da el resultado esperado (que en este caso dejamos como ejercicio para el lector; bueno, es 2). Podemos hacernos una funci√≥n de andar por casa para hacer la prueba:</p>
                    <pre><code>function testSum()
                    {
                      if (sum(1, 1) != 2)
                      {
                        console.error(&#39;Invalid result&#39;);
                        return;
                      }
                      console.log(&#39;Valid result&#39;);
                    }</code></pre>
                    <p>Para una prueba sencilla no necesitamos m√°s. Ahora a√±adimos otra prueba para la funci√≥n <code>substract()</code>, que sorprendentemente resta dos n√∫meros:</p>
                    <pre><code>function testSubstract()
                    {
                      if (substract(2, 1) != 1)
                      {
                        console.error(&#39;Invalid result&#39;);
                        return;
                      }
                      console.log(&#39;Valid result&#39;);
                    }</code></pre>
                    <p>Y hacemos una funci√≥n que llame a todas las pruebas para correrlas juntas:</p>
                    <pre><code>function test()
                    {
                      testAdd();
                      testSubstract();
                    }</code></pre>
                    <p>Cuando tenemos varias pruebas, la salida empieza a volverse engorrosa: para saber si todas las pruebas funcionan, tenemos que parsear un mont√≥n de texto y buscar posibles errores. Es entonces cuando empezamos a ver asteriscos en la salida, m√∫ltiples filas de signos igual (<code>======</code>), etc√©tera.</p>
                    <h2 id="pruebas-s√≠ncronas">Pruebas s√≠ncronas</h2>
                    <p>¬øC√≥mo se har√≠a esto mismo con testing?</p>
                    <p>Para empezar tenemos las funciones <code>testing.success()</code> y <code>testing.failure()</code> que simplifican el mostrar mensajes de error, con colores y todo. La primera prueba quedar√≠a as√≠:</p>
                    <pre><code>function testSum()
                    {
                      if (sum(1, 1) != 2)
                      {
                        testing.failure(&#39;Invalid result&#39;);
                        return;
                      }
                      testing.success(&#39;Valid result&#39;);
                    }</code></pre>
                    <p>Hum, no hemos ganado demasiado. Vamos a usar algo un pel√≠n m√°s potente: las aserciones. Para empezar la m√°s sencilla: <code>testing.assert()</code>, que nos permite evaluar una condici√≥n. Si es falsa se mostrar√° una condici√≥n de error:</p>
                    <pre><code>function testSum()
                    {
                      testing.assert(sum(1, 1) == 2, &#39;Invalid result&#39;);
                      testing.success(&#39;Valid result&#39;);
                    }</code></pre>
                    <p>Esto es mejor: si la condici√≥n es falsa, se muestra el mensaje que va en el segundo par√°metro en rojo. Pero todav√≠a tenemos otra opci√≥n m√°s potente: <code>testing.assertEquals()</code>, que comprueba que el valor obtenido sea igual al deseado. No es mucho m√°s breve pero queda m√°s claro:</p>
                    <pre><code>function testSum()
                    {
                      testing.assertEquals(sum(1, 1), 2, &#39;Invalid result&#39;);
                      testing.success(&#39;Valid result&#39;);
                    }</code></pre>
                    <p>Ahora queremos correr todas las pruebas juntas. Es muy sencillo: usamos la funci√≥n <code>testing.run()</code> que nos permite a√±adir m√∫ltiples funciones y probarlas todas en secuencia:</p>
                    <pre><code>function test()
                    {
                      testing.run({
                        add: testAdd,
                        substract: testSubstract,
                      });
                    }</code></pre>
                    <p>El primer par√°metro es un objeto que contiene por cada atributo una funci√≥n de prueba; por ahora no necesitamos m√°s.</p>
                    <h2 id="pruebas-as√≠ncronas">Pruebas as√≠ncronas</h2>
                    <p>Supongamos que nuestra prueba es algo m√°s compleja: queremos leer el fichero <code>pepito.txt</code> y comprobar que contiene el valor esperado, <code>"pepito"</code>. Ser√≠a algo as√≠:</p>
                    <pre><code>function testFile()
                    {
                      fs.readFile(&#39;pepito.txt&#39;, function(error, result)
                      {
                        if (result != &#39;pepito&#39;)
                        {
                          console.error(&#39;Invalid file contents&#39;);
                          return;
                        }
                        console.log(&#39;Valid file contents&#39;);
                      });
                    }</code></pre>
                    <p>¬øC√≥mo nos ayuda testing? La librer√≠a est√° pensada espec√≠ficamente para esto, as√≠ que en este caso es cuando m√°s vamos a poder ganar us√°ndola. Ya hemos visto c√≥mo usar aserciones; ahora vamos a usar la magia de las callbacks, a√±adi√©ndole una a la funci√≥n <code>testFile()</code>. Esta callback se la pasaremos a su vez a las funciones de testing, siempre como √∫ltimo par√°metro:</p>
                    <pre><code>function testFile(callback)
                    {
                      fs.readFile(&#39;pepito.txt&#39;, function(error, result)
                      {
                        testing.assertEquals(result, &#39;pepito&#39;, &#39;Invalid file contents&#39;, callback);
                        testing.success(&#39;Valid file contents&#39;, callback);
                      });
                    }</code></pre>
                    <p>Ahora llamamos a la funci√≥n <code>testFile()</code> con una callback que recibir√°, como es habitual en node.js, error y resultado:</p>
                    <pre><code>testFile(function(error, result)
                    {
                      if (error)
                      {
                        console.error(&#39;Error: %s&#39;, error);
                      }
                      else
                      {
                        console.log(&#39;Success: %s&#39;, result);
                      }
                    });</code></pre>
                    <p>Si tenemos varias pruebas, pasaremos la callback a <code>testing.run()</code>:</p>
                    <pre><code>function test(callback)
                    {
                      testing.run({
                        file: testFile,
                        web: testWeb,
                      }, callback);
                    }</code></pre>
                    <p>Y la invocaremos con nuestra callback a medida:</p>
                    <pre><code>test(function(error, result)
                    {
                      if (error)
                      {
                        console.error(&#39;Error: %s&#39;, error);
                      }
                      else
                      {
                        console.log(&#39;Success: %s&#39;, result);
                      }
                    });</code></pre>
                    <p>La librer√≠a se encargar√° de correr las funciones una tras otra, hasta que se encuentre un error o hasta que se terminen. En el primer caso llamar√° a la callback con un par√°metro de error; en el segundo, con un resultado.</p>
                    <p>Sencillo, ¬øverdad?</p>
                    <h2 id="tiempos-fuera">Tiempos fuera</h2>
                    <p>A veces las funciones as√≠ncronas no llegan a llamar a la callback, de forma que el c√≥digo se interrumpe. Resultado: una prueba que nunca termina. Nos interesa tratar esta condici√≥n y asegurarnos de que no se d√© nunca en producci√≥n, ya que lleva al temible efecto de p√°ginas que nunca responden.</p>
                    <p>Por defecto, testing espera un segundo para cada prueba; si tras ese tiempo no se ha llamado a la callback, considera que ha habido un error y concluye las pruebas.</p>
                    <p>Cuando usamos <code>testing.run()</code> podemos especificar un timeout en milisegundos como segundo par√°metro:</p>
                    <pre><code>function test(callback)
                    {
                      testing.run({
                        add: testAdd,
                        substract: testSubstract,
                      }, 10000, callback);
                    }</code></pre>
                    <p>De esta forma, la librer√≠a se esperar√° 10 segundos antes de dar las pruebas por finalizadas. Esto puede ser √∫til si tenemos muchos accesos externos o tareas que llevan bastante tiempo.</p>
                    <h2 id="corriendo-las-pruebas">Corriendo las pruebas</h2>
                    <p>A√∫n hay algo m√°s: testing nos proporciona una callback a prop√≥sito para mostrar errores y resultados, <code>testing.show()</code>, as√≠ que s√≥lo tenemos que pas√°rsela a nuestras funciones de <code>test()</code>:</p>
                    <pre><code>// run tests
                    test(testing.show);</code></pre>
                    <p>Esta l√≠nea ir√≠a al final de nuestro fichero mientras probamos.</p>
                    <p>Un ejemplo muy sencillo lo podemos ver si corremos npm test testing, lo que correr√° todas las pruebas del propio paquete testing:</p>
                    <pre><code>$ npm test testing
                     
                    $ testing@0.0.2 test /home/chenno/projects/loadtest/node_modules/testing
                    $ node index.js
                     
                    [Thu Jul 11 2013 22:43:49 GMT+0200 (CEST)] NOTICE success
                    [Thu Jul 11 2013 22:43:49 GMT+0200 (CEST)] ERROR test; do not consider
                    [Thu Jul 11 2013 22:43:49 GMT+0200 (CEST)] NOTICE All tests successful: { successFailure: undefined,
                      assert: undefined }</code></pre>
                    <p>Mucha gente ejecuta las pruebas una vez y luego se olvida de ellas, con el resultado de que su c√≥digo termina envejeciendo seg√∫n se va modificando. Es molesto tener que a√±adir (o descomentar) la l√≠nea <code>test(testing.show)</code>; cada vez que hacemos un cambio.</p>
                    <p>Para evitarlo, podemos correr nuestras pruebas s√≥lo si el fichero se invoca directamente. El siguiente c√≥digo puede ser √∫til:</p>
                    <pre><code>// run tests if invoked directly
                    if (__filename == process.argv[1])
                    {
                        test(testing.show);
                    }</code></pre>
                    <p>Ahora s√≥lo tienes que correr el fichero directamente:</p>
                    <pre><code>$ node myfile.js</code></pre>
                    <p>para ejecutar todas las pruebas que haya en el fichero cada vez.</p>
                    <h2 id="conclusi√≥n">Conclusi√≥n</h2>
                    <p>Ya no tienes excusa para no tener un juego de pruebas completo y actualizado en node.js. Te aseguro que el esfuerzo de crearlas y mantenerlas se pagar√° al menos 10 veces durante el tiempo de tu proyecto.</p>
								</div>
							</section>
							<section id="last">
								<div class="container">
									<p>
									Original publicado en <a href="http://www.godtic.com/blog/2013/07/11/pruebas-asincronas-en-node-js/">GodTIC</a> el 2013-07-11.
									</p>
									<p>
									Back to the <a href="/">index</a>.
									</p>
								</div>
							</section>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<ul class="copyright">
								<li>
									¬© <a href="mailto:alexfernandeznpm@gmail.com">Alex Fern√°ndez</a>.
									<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
								</li>
								<li>Original design: <a href="http://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</section>

			</div>
	</body>
</html>
