<!DOCTYPE HTML>
<!--
	Read Only by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)

	Modified by Alex Fern√°ndez
	https://pinchito.es/ | @pinchito
-->
<html>
	<head>
		<title>Tras la arquitectura perfecta</title>
		<meta charset="utf-8" />
		<meta name="description" content="Tras la arquitectura perfecta ‚Äî La
arquitectura fluida, parte 1" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@pinchito" />
		<meta name="twitter:title" content="Tras la arquitectura perfecta ‚Äî La
arquitectura fluida, parte 1" />
		<meta name="twitter:description" content="" />
		<meta name="twitter:image" content="" />
		<link rel="stylesheet" href="/css/main.css" />
		<link rel="canonical" href="https://pinchito.es/2015/arquitectura-fluida-1-arquitectura-perfecta" />
		<link rel="shortcut icon" href="/favicon.png" type="image/png" />
		<!--[if lte IE 8]><link rel="stylesheet" href="/css/ie8.css" /><![endif]-->
	</head>
	<body>

		<!-- Header -->
			<section id="header">
				<header>
					<p class="home"><a class="home" href="/">pinchito.es</a></p>
					<p>
					<a href="/about">about</a>
					<br/>
					<a href="/cv">CV</a>
					<br/>
					<a href="/speaker">speaker</a>
					<br/>
					<a href="/rss.xml">
						<svg aria-hidden="true" class="rss-icon" width="18" height="18" viewBox="0 0 18 18"><path d="M3 1a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2zm0 1.5c6.9 0 12.5 5.6 12.5 12.5H13C13 9.55 8.45 5 3 5zm0 5c4.09 0 7.5 3.41 7.5 7.5H8c0-2.72-2.28-5-5-5zm0 5c1.36 0 2.5 1.14 2.5 2.5H3z"></path></svg>
						RSS feed</a>
					</p>
					<p>
					<a id="follower" href="https://twitter.com/intent/follow?screen_name=pinchito" target="_blank"><i id="birdie"></i>@pinchito</a>
					<br />
					<a rel="me" href="https://mastodon.social/@pinchito" target="_blank">üêò @pinchito@mastodon.social</a>
					<br/>
					<a href="https://github.com/alexfernandez" aria-label="Follow @alexfernandez on GitHub">alexfernandez @ GitHub</a>
					</p>
					<p>
					This site is cookie free! No tracking is done on your browser.
					</p>
					<a href="https://librecounter.org/referer/show" target="_blank">
					<img src="https://librecounter.org/counter.svg" referrerPolicy="unsafe-url">
					</a>
				</header>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<section id="zero">
							<p class="home"><a class="home" href="/">pinchito.es</a></p>
						</section>

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h1>Tras la arquitectura perfecta</h1>
										<p>La arquitectura fluida, parte 1<p>
									</header>
																				<figure>
<img src="pics/arquitectura-fluida-1.jpg" title="Deep Blue Dolphin Love"
alt="Imagen: ¬© Patrik Jones" />
<figcaption aria-hidden="true">Imagen: <a
href="https://creativecommons.org/licenses/by/2.0/">¬©</a> <a
href="https://www.flickr.com/photos/laprimadonna/4881676285">Patrik
Jones</a></figcaption>
</figure>
<p>En muchas empresas hay departamentos de arquitectura cuya misi√≥n es
decidir c√≥mo se va a organizar cada proyecto de software. Deciden el
dise√±o a alto nivel, en cu√°ntas capas se dividir√°, qu√© base de datos
usar y otros detalles importantes.</p>
<p>¬øPor qu√© cambiar la base de datos en cada proyecto? ¬øPor qu√© no se
usa siempre la misma? Para construir edificios no existe un material
perfecto: a veces es mejor la piedra, otras el ladrillo y otras incluso
el acero. Tampoco hay una forma perfecta para todos los edificios:
cuadrados, rect√°ngulos, cilindros y semiesferas se comportan de forma
distinta bajo la carga. Lo mismo ocurre con los programas de software:
cada uno tiene unas restricciones operacionales diferentes, y se
comporta mejor en ciertas circunstancias.</p>
<h1 id="qu√©-es-la-arquitectura">Qu√© es la arquitectura</h1>
<p>Puede que nos ayude a centrar la discusi√≥n si definimos qu√© es este
negocio de ‚Äúarquitectura‚Äù en software.</p>
<p>En esencia se trata de dividir el sistema en bloques de alto nivel, y
ordenar las relaciones entre ellos. La organizaci√≥n en componentes suele
derivar en la organizaci√≥n f√≠sica de las m√°quinas y la elecci√≥n de
lenguaje y programas auxiliares, como por ejemplo qu√© base de datos
usar. De ah√≠ vienen cosas como la arquitectura en tres capas que se
populariz√≥ hace a√±os, o la moda m√°s reciente de usar gestores de colas
en sistemas escalables.</p>
<p>Curiosamente, es m√°s raro que en la arquitectura se incluya el dise√±o
a alto nivel del propio software, por ejemplo: la divisi√≥n en m√≥dulos de
npm o en librer√≠as, c√≥mo se dividen los servicios de una API en el
c√≥digo o qu√© hacer con el c√≥digo compartido entre diferentes programas.
Tampoco se suelen discutir asuntos m√°s de DevOps como la forma de
desplegar el c√≥digo o la creaci√≥n de entornos de integraci√≥n, ya que
suelen caer del lado del departamento de producci√≥n. As√≠ que por ahora
nos limitaremos a considerar la organizaci√≥n en m√°quinas y qu√© software
usar.</p>
<h2 id="modas-en-arquitectura">Modas en arquitectura</h2>
<p>En los a√±os 80 la moda empresarial era tener una <a
href="http://www.computerhistory.org/revolution/minicomputers/11/366/1946">minicomputadora</a>
(del tama√±o de un armario peque√±o) y m√∫ltiples terminales conectados. La
llegada de los ordenadores ‚Äúpersonales‚Äù fue una revoluci√≥n, ya que hasta
entonces era impensable darle un ordenador en exclusiva a un
trabajador.</p>
<p>En los 90 se popularizaron las arquitecturas cliente-servidor. Se
separaban as√≠ los programas que resid√≠an en un servidor y que generaban
respuestas, de los clientes que utilizaban estas respuestas. Poco
despu√©s llegar√≠an protocolos de comunicaci√≥n entre servidores como CORBA
y un poco m√°s tarde <a
href="https://en.wikipedia.org/wiki/XML#History">XML</a>.</p>
<p>A principios del siglo XXI llegaron las <a
href="https://en.wikipedia.org/wiki/Multitier_architecture#Three-tier_architecture">arquitecturas
de tres capas</a>: capa de presentaci√≥n, capa de l√≥gica y base de datos.
Era un refinamiento del paradigma cliente-servidor donde se separaba el
repositorio de datos, la l√≥gica de negocio y la presentaci√≥n de la
informaci√≥n. Tambi√©n se invent√≥ el rid√≠culo <a
href="https://en.wikipedia.org/wiki/Enterprise_service_bus#History"><em>Enterprise
Service Bus</em></a>, que empez√≥ a infectar los diagramas corporativos
all√° por 2002, y el <a
href="https://en.wikipedia.org/wiki/Business_process_modeling">modelado
de procesos de negocio</a> que por suerte parece que ha ca√≠do en
desuso.</p>
<p>En los a√±os 10 las bases de datos NoSQL han adquirido protagonismo.
Los servidores sin estado son de uso com√∫n, al igual que los gestores de
colas. Son mejoras de este tipo las que han permitido la creaci√≥n de
servicios escalables m√°s all√° de lo que se cre√≠a posible en d√©cadas
pasadas.</p>
<p>En general, un sistema de software suele poder fecharse con bastante
precisi√≥n s√≥lo con ver la arquitectura que implementa. No deja de ser
curioso que se deje al arbitrio de modas un asunto tan serio como la
arquitectura de sistemas, sobre todo en empresas grandes. Lo cierto es
que cuantos m√°s elementos seamos capaces de utilizar, m√°s flechas
tendremos en nuestro carcaj para cuando las necesitemos.</p>
<h2 id="perfecci√≥n-en-arquitectura">Perfecci√≥n en arquitectura</h2>
<p>Los dise√±os cl√°sicos de los templos y teatros griegos siguen siendo
admirados casi 2500 a√±os despu√©s de su construcci√≥n. As√≠ que, ¬øpor qu√©
no seguimos construyendo como ellos? Los materiales cambian, las
t√©cnicas avanzan, y las necesidades de los ocupantes tambi√©n.</p>
<p>En la arquitectura de sistemas de software tambi√©n se mejora
constantemente. Si dominamos nuevas t√©cnicas seremos m√°s vers√°tiles como
profesionales. Pero no es √©se el motivo real por el que la arquitectura
perfecta no existe.</p>
<p>Cada proyecto tiene su √°mbito de operaci√≥n, y su personal asignado.
Construir una p√°gina personal que va a recibir unas pocas visitas al d√≠a
usando Erlang, un lenguaje dise√±ado para sistemas telef√≥nicos de alta
concurrencia, es tan rid√≠culo como querer hacer un clon de Twitter en
Visual Basic. De ah√≠ que tengamos que conocer los requisitos funcionales
y operativos de un sistema antes de poder empezar a hablar de
arquitectura.</p>
<h1 id="requisitos-cambiantes">Requisitos cambiantes</h1>
<p>En las inmortales palabras citadas por Steve McConnell en <a
href="http://www.stevemcconnell.com/cc.htm">Code Complete</a>:</p>
<blockquote>
<p>Los requisitos son como el agua: es m√°s f√°cil construir sobre ellos
cuando est√°n congelados.</p>
</blockquote>
<p>Por desgracia, la vida es dura y los requisitos cambian. Llega un
momento de la vida en la que todo ingeniero de software comprende que
hay valor en permitir que los requisitos cambien: pretender comprender a
la perfecci√≥n un sistema antes de empezar a construirlo no s√≥lo es una
quimera; adem√°s es una p√©rdida de tiempo. Es raro el negocio donde se
conocen a la perfecci√≥n los requisitos de los clientes antes de empezar
a darles servicio, y m√°s raro a√∫n dar con la tecla correcta a la primera
iteraci√≥n.</p>
<p>Un sistema de software tiene que poder evolucionar durante su vida
√∫til. Esto significa responder a requisitos cambiantes sin excesivas
remodelaciones.</p>
<h2 id="requisitos-funcionales">Requisitos funcionales</h2>
<p>Empecemos con una an√©cdota, en este caso con trasfondo militar. El
avi√≥n bombardero <a
href="http://www.af.mil/AboutUs/FactSheets/Display/tabid/224/Article/104465/b-52-stratofortress.aspx">B-52
<em>stratofortress</em></a> empez√≥ a operar en 1952 y las √∫ltimas
unidades se construyeron en 1963; actualmente 76 aparatos siguen en
servicio tras m√°s de seis d√©cadas de actualizaciones. Durante este
tiempo se han actualizado para usar motores turbofan y combustible
alternativo, lanzar armas nucleares y misiles inteligentes guiados, se
han reparado <a
href="https://en.wikipedia.org/wiki/Boeing_B-52_Stratofortress#Design">m√∫ltiples
problemas estructurales</a>, mejorado la avi√≥nica, y habilitada la
visi√≥n noctura para los pilotos. Se estima que podr√° seguir en servicio
activo al menos hasta 2040. En resumen: es un bombardero dise√±ado
durante la guerra de Corea y fabricado mientras JFK era presidente, que
seguir√° en uso durante al menos otros 25 a√±os.</p>
<p>Como ingenieros, nuestra mayor aspiraci√≥n es seguramente que lo que
construyamos dure en el tiempo. Para eso es necesario que pueda
actualizarse y mejorarse, a√±adiendo nuevas funcionalidades seg√∫n se
necesiten. Gracias a la magia del software no tenemos que sacar nuestros
sistemas del servicio para actualizarlos; basta con hacer una copia del
c√≥digo y reemplazar el de producci√≥n cuando est√°n listas las mejoras.
As√≠ que nos resulta relativamente f√°cil que nuestro software haga cosas
nuevas. ¬øO no? S√≥lo tenemos que extenderlo para que haga cosas m√°s all√°
de su prop√≥sito original. Excepto cuando no se puede.</p>
<p>Todos conocemos alg√∫n proyecto que ha pasado su fecha de expiraci√≥n.
Nadie quiere tocar el c√≥digo porque se ha convertido en una masa
siniestra de <em>spaghetti</em>. Las modificaciones son inmanejables y
cada vez que se hace un cambio en un sitio, se rompe algo en otro
aparentemente no relacionado.</p>
<p>Nuestra misi√≥n es mantener el software flexible para que podamos
seguir a√±adiendo funcionalidades. Eso lleva alg√∫n esfuerzo extra, sin
duda, pero la recompensa es grande cuando el proyecto es realmente
exitoso.</p>
<h2 id="requisitos-operacionales">Requisitos operacionales</h2>
<p>Las circunstancias en las que nuestro sistema tiene que trabajar
cambian, para bien o para mal. A menudo necesitamos ampliar el rango
operativo del sistema sin a√±adir funcionalidades nuevas.</p>
<h3 id="planificaci√≥n-de-capacidad">Planificaci√≥n de capacidad</h3>
<p>Un caso importante es la planificaci√≥n de la capacidad necesaria para
dar servicio, lo que se conoce en ingl√©s como <em>capacity
planning</em>. Un producto exitoso a menudo dobla el n√∫mero de usuarios
en un a√±o, o incluso en meses: en 2013 <a
href="http://techcrunch.com/2013/12/18/uber-lyft/">Uber</a> crec√≠a al
400% por a√±o, mientras que su competidora Lyft lo hac√≠a a un ritmo
todav√≠a m√°s vertiginoso que supon√≠a multiplicar su facturaci√≥n por 20 al
a√±o.</p>
<p>¬øEs posible que el mismo sistema sea capaz de crecer para soportar
todo el tr√°fico que le echemos? Si usamos la planificaci√≥n de capacidad
tradicional seguramente intentemos predecir el tr√°fico que vamos a tener
durante todo el a√±o en base a los datos del a√±o anterior, para ir
presupuestando el n√∫mero de servidores que vamos a necesitar. Tambi√©n
necesitaremos redimensionar todos nuestros componentes para aguantar el
tr√°fico extra. Esto, que era pr√°ctica est√°ndar hace unos a√±os, ahora
ser√≠a un suicidio: la tasa de crecimiento puede ser exponencial y
doblarse cada poco tiempo, aunque tambi√©n puede mantenerse estacionaria
de repente durante meses.</p>
<p>¬øC√≥mo predecir el tr√°fico que tendremos, no ya al final de un a√±o,
sino s√≥lo dentro de un mes? Respuesta: no podemos. S√≥lo podemos intentar
ir un paso por delante del tr√°fico, responder r√°pido a los cambios y no
adelantar demasiado los acontecimientos.</p>
<blockquote>
<h4 id="caso-pr√°ctico-mediasmart-mobile">Caso pr√°ctico: MediaSmart
Mobile</h4>
<figure>
<img src="pics/mediasmart-krps.jpg"
alt="Peticiones por segundo en MediaSmart Mobile" />
<figcaption aria-hidden="true">Peticiones por segundo en MediaSmart
Mobile</figcaption>
</figure>
<p>Esta gr√°fica muestra los picos de peticiones por segundo que hemos
recibido en MediaSmart Mobile desde 2013. Durante el primer a√±o el
volumen fue creciendo linealmente, pasando de 2 a 12 krps (miles de
peticiones por segundo). A principios de 2014 pas√≥ algo curioso: el
ritmo se aceler√≥, y pasamos de 15 a 100 krps a finales de a√±o. Pero en
2015 el ritmo est√° decelerando de nuevo: apenas pasaremos de 210 krps
antes de final de a√±o.</p>
<p>Si a principios 2014 hubi√©ramos pintado una l√≠nea recta para predecir
el tr√°fico del a√±o, habr√≠amos calculado alrededor de 25 krps
(definitivamente por debajo de 30 krps); a final de a√±o ten√≠amos 100
krps. Por otra parte, si hubi√©ramos seguido la curva exponencial para
2015, a final de a√±o habr√≠amos andado por 600 krps; la cifra real anda
cerca de las 200 krps.</p>
</blockquote>
<h3 id="bases-de-datos">Bases de datos</h3>
<p>Cada base de datos tiene varias caracter√≠sticas que la hacen adecuada
en ciertas situaciones, y que la descartan en otras. Entre ellas:</p>
<ul>
<li>Rango operativo: ¬øcu√°ntas peticiones por segundo admite?</li>
<li>Elementos funcionales: ¬øqu√© tipos de datos permite guardar? ¬øQu√©
tipo de consultas se pueden hacer?</li>
<li>Tiempo de respuesta: ¬øcu√°ntos milisegundos se tarda en servir cada
petici√≥n?</li>
<li>Condiciones de operaci√≥n: ¬øcu√°ntos servidores (y de qu√© tipo) se
necesitan como m√≠nimo? ¬øHasta cu√°ntos escala?</li>
</ul>
<p>Durante mucho tiempo se trabaj√≥ bajo el paradigma de ‚Äúla base de
datos perfecta‚Äù: un mismo programa que escalara de casi cero
(dispositivos muy limitados en recursos, como m√≥viles) a infinito (un
cluster con tantos nodos como queramos). Con la llegada de las bases de
datos NoSQL asistimos a una explosi√≥n evolutiva de bases de datos muy
diferentes: en memoria o en cluster; clave-valor o con estructuras
complejas; que admiten SQL y que no; etc√©tera. Cada tipo es adecuado
para unas condiciones operativas diferentes, y tienen costes asociados
muy distintos.</p>
<h3 id="costes-bajos">Costes bajos</h3>
<p>Por √∫ltimo, pero no menos importante, tenemos los costes de operaci√≥n
del sistema. Alquilar servidores en la nube no sale barato; si no
optimizamos su uso al m√°ximo probablemente tiremos un mont√≥n de
dinero.</p>
<blockquote>
<h4 id="caso-pr√°ctico-mediasmart-mobile-1">Caso pr√°ctico: MediaSmart
Mobile</h4>
<figure>
<img src="pics/mediasmart-daily-traffic.png"
alt="Tr√°fico diario en MediaSmart Mobile" />
<figcaption aria-hidden="true">Tr√°fico diario en MediaSmart
Mobile</figcaption>
</figure>
<p>En MediaSmart el tr√°fico nocturno sol√≠a ser menos de una cuarta parte
del pico diario: en la gr√°fica se aprecia un m√≠nimo de 2.5 millones de
peticiones por minuto, frente a casi 7 millones en el pico diario
(alrededor de las 8 de la tarde). <em>Nota</em>: Amazon AWS mide las
peticiones <em>por minuto</em>, en lugar de las peticiones <em>por
segundo</em> que hemos visto arriba. 6M por minuto equivale a 100
krps.</p>
<p>Mantener arrancados los servidores todo el d√≠a supon√≠a desperdiciar
gran parte de la capacidad, y como en Amazon se paga por hora de
servidor los costes eran astron√≥micos. Es esencial poder usar un n√∫mero
variable de servidores, y eso nos obliga a tener un balanceador de carga
que pueda admitir nuevas instancias din√°micamente.</p>
</blockquote>
<h3 id="velocidad-del-cambio">Velocidad del cambio</h3>
<p>La velocidad a la que somos capaces de realizar cambios en nuestros
sistemas es cr√≠tica. Demasiado lento, y no seremos capaces de absorber
un tr√°fico creciente de peticiones o de mantener los costes controlados;
demasiado r√°pido, y nuestro sistema estar√° ca√≠do todo el tiempo.</p>
<p>Si tu proveedor de servidores en la nube sube los precios un 300% de
un d√≠a para otro, cosa que <a
href="http://highscalability.com/blog/2011/9/7/what-google-app-engine-price-changes-say-about-the-future-of.html">ha
ocurrido en el pasado</a>, ¬øcu√°nto tiempo tarda tu equipo en migrar a un
nuevo proveedor?</p>
<p>Y si ma√±ana decides montar un CPD propio y albergar tus propios
servidores, ¬øcu√°nto tardar√°s en replicarlos? ¬øC√≥mo realizar√°s el cambio
en el momento clave para empezar a dar servicio?</p>
<h1 id="la-arquitectura-fluida">La arquitectura fluida</h1>
<p>¬øCu√°l es la soluci√≥n para acomodar tanto cambio? Nuestra humilde
sugerencia es mantener la arquitectura del sistema fluida, sin tomar
decisiones que comprometan su integridad. Tenemos que ser capaces de
pasar de un estado a otro, intentando dar servicio todo el tiempo.</p>
<p>Al oir esto un arquitecto de los de verdad, de los que juntan
piedras, seguramente tendr√≠a problemas para contener la risa. ¬øC√≥mo se
pueden cambiar las vigas maestras de un edificio mientras los habitantes
est√°n viviendo dentro?</p>
<p>Los ingenieros de software tenemos una gran ventaja frente a otras
ingenier√≠as m√°s tradicionales: no trabajamos con el mundo real, r√≠gido y
fr√°gil, sino con software, que es infinitamente moldeable.</p>
<p>Si encontramos restricciones en esta maleabilidad suele ser porque
alguien no ha hecho bien su trabajo. Subiendo de nivel paulatinamente,
encontramos cosas como:</p>
<ul>
<li>c√≥digo duplicado, donde hay que modificar varios trozos de c√≥digo
para cambiar cualquier cosa, dificultando los cambios;</li>
<li>dependencias cruzadas, que hacen que un cambio en una parte tenga
efectos colaterales en partes no relacionadas;</li>
<li>drivers imbricados en m√∫ltiples secciones del c√≥digo, que dificultan
migrar bases de datos u otros componentes similares.</li>
</ul>
<p>Vamos a centrarnos en las restricciones que nos dificultan una
migraci√≥n.</p>
<h2 id="reversibilidad-y-termodin√°mica">Reversibilidad y
termodin√°mica</h2>
<p>En este punto vamos a tomar un desv√≠o que nos llevar√° de viaje a la
intemporal tierra de la termodin√°mica.</p>
<p>Seguro que has o√≠do hablar de ‚Äúentrop√≠a‚Äù: es un t√©rmino muy popular
entre los divulgadores cient√≠ficos, que a menudo lo corrompen
asign√°ndole significados corrientes como ‚Äúdesorden‚Äù, ‚Äúirregularidad‚Äù y
similares. Es probable que no te sorprenda que la entrop√≠a tiene una
definici√≥n muy precisa, o m√°s bien varias definiciones equivalentes.</p>
<p>No es sencillo calcular la entrop√≠a de un sistema, y menos todav√≠a
medir los flujos de entrop√≠a que ocurren mientras evoluciona.</p>
<p>Por suerte, podemos tomar un atajo: un sistema reversible es, por
definici√≥n, el que consigue que la entrop√≠a se mantenga en el m√≠nimo
posible. No por casualidad tambi√©n es el m√°s eficiente. Y adem√°s es muy
f√°cil saber cu√°ndo un sistema es reversible: cuando est√° en todo momento
en equilibrio.</p>
<p>En 2012 explor√© en <a
href="../2012/reversible-engineering-part-1">estos</a> <a
href="../2012/reversible-engineering-part-2">tres</a> <a
href="../2012/reversible-engineering-part-3">art√≠culos</a> (en ingl√©s)
una idea similar a la que he desarrollado aqu√≠: la ingenier√≠a
reversible, o c√≥mo trabajar siempre cerca del equilibrio. Las ideas
clave son: no malgastar energ√≠a, ir lo m√°s despacio que sea posible, y
evitar turbulencias.</p>
<p>En resumen, podemos considerar reversible un sistema que puede
invertirse sin consumir energ√≠a extra. Al mismo tiempo, si revertir el
funcionamiento del sistema requiere energ√≠a extra, entonces el sistema
no es reversible.</p>
<h2 id="migraciones">Migraciones</h2>
<p>Para pasar de una arquitectura a otra normalmente tenemos que
realizar un cambio, sea de m√°quinas, de programas, de c√≥digo o de datos.
Las migraciones son claramente cruciales para nuestro objetivo de tener
una arquitectura fluida: si nuestro sistema pasa de un estado a otro
suavemente y sin turbulencias, es decir que las migraciones son tambi√©n
fuidas, entonces podremos considerar que tenemos una arquitectura
maleable.</p>
<h3 id="migraci√≥n-sin-downtime">Migraci√≥n sin <em>downtime</em></h3>
<p>Para que cada migraci√≥n sea fluida es un requisito indispensable que
no haya un paso brusco entre un estado y el siguiente. Es decir, que no
dejemos en ning√∫n momentode dar servicio. La t√©cnica b√°sica para
conseguirlo es la capa de compatibilidad: un elemento intermedio que
ponemos entre el c√≥digo viejo y el nuevo y que facilita la
transici√≥n.</p>
<p>Supongamos que vamos a migrar un servicio de una m√°quina a otra. La
capa de compatibilidad en este caso ser√° una m√°quina intermedia (un
proxy) que dirigir√° el tr√°fico a una u otra seg√∫n un par√°metro de
configuraci√≥n. Primero redirigiremos los accesos a esta m√°quina, que los
desviar√° al antiguo servidor. A continuaci√≥n, cuando estemos preparados
redirigiremos el tr√°fico del proxy a la nueva m√°quina.</p>
<p>La capa de compatibilidad puede ser tambi√©n un elemento de software,
por ejemplo un <em>driver</em> capaz de hablar con la base de datos
antigua y con la nueva, seg√∫n un par√°metro de configuraci√≥n.</p>
<h3 id="reversibilidad">Reversibilidad</h3>
<p>Tambi√©n tenemos que tener claro c√≥mo revertir la migraci√≥n: poder
volver a la situaci√≥n inicial con el m√≠nimo esfuerzo. Idealmente, para
revertir todos los cambios s√≥lo tenemos que darle a un bot√≥n, cambiar
una opci√≥n de configuraci√≥n, modificar un √∫nico par√°metro, en
definitiva: invertir un bit.</p>
<pre><code>var MIGRATION = false;</code></pre>
<p>¬øCrees que es posible revertir los cambios de forma tan sencilla? Hay
muchos ejemplos de sistemas que son as√≠ de f√°ciles de revertir: el bot√≥n
de ‚Äúdeshacer‚Äù en un programa de edici√≥n de textos, o los cambios en un
repositorio git usando el comando <code>git revert</code>. Nuestro reto
es hacer que un sistema complejo compuesto de varias piezas vuelva a su
estado inicial con la misma facilidad.</p>
<p>Por otra parte, queremos (dentro de lo posible) no tener que usar
este bot√≥n de deshacer, a no ser que la migraci√≥n sea un fracaso
absoluto. Normalmente ante peque√±os problemas es m√°s rentable
arreglarlos y seguir adelante que volver atr√°s. Pero tener ese mecanismo
de seguridad es tan importante como para un trapecista tener una red
debajo, aunque por supuesto no planee usarla cuando sale a la pista.</p>
<h3 id="tipos-de-migraci√≥n">Tipos de migraci√≥n</h3>
<p>Vamos a ver los tipos principales de migraci√≥n por encima.</p>
<p><em>M√°quinas</em>: Normalmente cambiar de m√°quinas no se considera un
asunto de arquitectura. Pero si miramos m√°s all√° del hierro, a menudo
nos encontramos con un sistema operativo m√°s moderno (o incluso
distinto), que puede requerir nuevos programas. Tambi√©n puede ser que
las m√°quinas tengan nuevas capacidades que requieren de cambios en el
c√≥digo, como los servidores multicore que nos invadieron hace un par de
d√©cadas. Adem√°s, cuando las m√°quinas migradas albergan grandes
cantidades de informaci√≥n suele haber una migraci√≥n de datos
asociada.</p>
<p><em>Programas</em>: Los cambios en un programa que no desarrollamos
directamente pueden ir desde un cambio de versi√≥n a un cambio completo
del programa que usaremos. En el primer caso puede ser que tengamos
peque√±os cambios de c√≥digo: por ejemplo, cada actualizaci√≥n de la base
de datos Oracle puede requerir peque√±os ajustes en las sentencias SQL
usadas. Cuando se cambia de programa puede que tengamos que cambiar el
driver, o incluso (si es una base de datos) migrar los datos. Por tanto
los cambios de programa a menudo llevan aparejados cambios de c√≥digo y/o
datos.</p>
<p><em>C√≥digo</em>: Cuando el c√≥digo est√° bajo nuestro control, cada
despliegue se convierte de hecho en una migraci√≥n: de la versi√≥n en
producci√≥n a una nueva. A veces tambi√©n tienen aparejadas migraciones de
datos, por ejemplo cuando hay un cambio de esquema en la base de
datos.</p>
<p><em>Datos</em>: Las migraciones de datos son el ejemplo m√°s claro de
cambio que debe manejarse con delicadeza. En este caso hay que mover o
redistribuir informaci√≥n, que suele ser lo m√°s delicado en una
migraci√≥n.</p>
<h3 id="migraciones-de-base-de-datos">Migraciones de base de datos</h3>
<p>Como hemos visto, las migraciones de datos son el final de la cadena:
cada tipo de migraci√≥n de arriba puede llevar aparejada una migraci√≥n de
datos, pero no viceversa. Adem√°s son delicadas porque podemos perder en
un momento informaci√≥n muy valiosa. Vamos a estudiarlas un poco m√°s en
detalle.</p>
<p>Hay un par de peculiaridades en los cambios de bases de datos que las
hace interesantes. En primer lugar, es bastante sencillo construir una
capa de compatibilidad que traduzca las operaciones entre dos bases de
datos, incluso aunque tengan modelos internos muy diferentes. Por
ejemplo, para hacer que una base de datos tradicional como PostgreSQL se
comporte como un almacenamiento clave-valor s√≥lo tenemos que crear una
tabla √∫nica con un campo clave y otro campo valor de tipo texto.</p>
<p>Otra peculiaridad es que en estas migraciones es importante migrar
por separado el acceso y los datos. Normalmente queremos migrar primero
los datos, y luego cambiar el acceso; todo ello por supuesto sin
<em>downtime</em>.</p>
<p>Los cambios de base de datos son ejemplos muy completos del tipo de
migraciones que estamos estudiando. M√°s adelante vamos a abusar de ellos
para ilustrar cada t√©cnica de migraci√≥n.</p>
<h1 id="fin-por-ahora">Fin (por ahora)</h1>
<p>En la <a href="arquitectura-fluida-2-estrategias-migracion">siguiente
parte</a> veremos varias estrategias que se pueden usar para realizar
una migraci√≥n.</p>
								</div>
							</section>
							<section id="last">
								<div class="container">
									<p>
									Publicado originalmente en <a
href="http://www.todojs.com/tras-la-arquitectura-perfecta-la-arquitectura-fluida/">TodoJS</a>
el 2015-11-09.
									</p>
									<p>
									Back to the <a href="/">index</a>.
									</p>
								</div>
							</section>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<ul class="copyright">
								<li>
									¬© <a href="mailto:alexfernandeznpm@gmail.com">Alex Fern√°ndez</a>.
									<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
								</li>
								<li>Original design: <a href="http://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</section>

			</div>
	</body>
</html>
