<!DOCTYPE HTML>
<!--
	Read Only by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)

	Modified by Alex Fern√°ndez
	https://pinchito.es/ | @pinchito
-->
<html>
	<head>
		<title>Estrategias de migraci√≥n</title>
		<meta charset="utf-8" />
		<meta name="description" content="Estrategias de migraci√≥n ‚Äî La
arquitectura fluida, parte 2" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@pinchito" />
		<meta name="twitter:title" content="Estrategias de migraci√≥n ‚Äî La
arquitectura fluida, parte 2" />
		<meta name="twitter:description" content="" />
		<meta name="twitter:image" content="" />
		<link rel="stylesheet" href="/css/main.css" />
		<link rel="canonical" href="https://pinchito.es/2015/arquitectura-fluida-2-estrategias-migracion" />
		<link rel="shortcut icon" href="/favicon.png" type="image/png" />
		<!--[if lte IE 8]><link rel="stylesheet" href="/css/ie8.css" /><![endif]-->
	</head>
	<body>

		<!-- Header -->
			<section id="header">
				<header>
					<p class="home"><a class="home" href="/">pinchito.es</a></p>
					<p>
					<a href="/about">about</a>
					<br/>
					<a href="/cv">CV</a>
					<br/>
					<a href="/speaker">speaker</a>
					</p>
					<p>
					<a id="follower" href="https://twitter.com/intent/follow?screen_name=pinchito" target="_blank"><i id="birdie"></i>@pinchito</a>
					<br />
					<a rel="me" href="https://mastodon.social/@pinchito" target="_blank">üêò @pinchito@mastodon.social</a>
					<br/>
					<a href="https://github.com/alexfernandez" aria-label="Follow @alexfernandez on GitHub">alexfernandez @ GitHub</a>
					<br/>
					<a href="https://www.youtube.com/channel/UCp5fMWhuqcbrvSJEOByeGwg">YouTube</a>
					</p>
					<p>
					This site is cookie free! No tracking is done on your browser.
					</p>
					<a href="https://librecounter.org/referer/show" target="_blank">
					<img src="https://librecounter.org/counter.svg" referrerPolicy="unsafe-url">
					</a>
				</header>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<section id="zero">
							<p class="home"><a class="home" href="/">pinchito.es</a></p>
						</section>

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h1>Estrategias de migraci√≥n</h1>
										<p>La arquitectura fluida, parte 2<p>
									</header>
																				<figure>
                    <img src="pics/arquitectura-fluida-2.jpg"
                    title="El puente del C√©sar sobre el Rhin"
                    alt="Imagen: John Soane" />
                    <figcaption aria-hidden="true">Imagen: <a
                    href="http://gabriel-scipio.blogspot.com.es/2012/01/el-puente-del-cesar.html">John
                    Soane</a></figcaption>
                    </figure>
                    <p>En la <a
                    href="arquitectura-fluida-1-arquitectura-perfecta">parte
                    anterior</a> vimos c√≥mo la arquitectura perfecta no
                    existe; nuestra √∫nica esperanza es poder migrar
                    r√°pidamente de una a otra para responder a los
                    cambios a los que nos enfrentamos.</p>
                    <p>Llegamos ahora a al cat√°logo de estrategias.
                    Vamos a describir varias t√©cnicas que se pueden usar
                    para realizar una migraci√≥n, de las m√°s bruscas a
                    las que son completamente reversibles.</p>
                    <h2 id="quieres-decir-patrones">¬øQuieres decir
                    ‚Äúpatrones‚Äù?</h2>
                    <p>Tras el gran √©xito del libro de Gamma <em>et
                    al</em>, <em>Design Patterns</em>, la palabra
                    ‚Äúpatr√≥n‚Äù se usa a menudo (y se abusa de ella a√∫n m√°s
                    a menudo) el dise√±o de sistemas. Los patrones vienen
                    a ser piezas que tienen su rango de aplicaci√≥n muy
                    concreto seg√∫n la situaci√≥n.</p>
                    <p>No es as√≠ en nuestro caso. Ante una migraci√≥n
                    podemos usar varias de las t√©cnicas que vamos a
                    describir. Podemos elegir una u otra seg√∫n lo fluida
                    que queramos que sea la migraci√≥n, no la
                    funcionalidad que queremos conseguir (que es siempre
                    la misma). De ah√≠ que prefiramos el t√©rmino
                    ‚Äúestrategia‚Äù, que adem√°s no est√° tan viciado por el
                    uso.</p>
                    <h2 id="probadas-en-combate">Probadas en
                    combate</h2>
                    <p>Todas las estrategias que vamos a describir est√°n
                    probadas en combate. Intentaremos ilustrar cada
                    estrategia con un caso pr√°ctico, aunque curiosamente
                    no es f√°cil encontrar publicaciones sobre
                    migraciones. Por ello para la mayor√≠a de ellas
                    tendremos que recurrir a ejemplos internos de
                    MediaSmart Mobile.</p>
                    <p>Aunque la mayor√≠a de los ejemplos son de
                    migraciones de bases de datos, las estrategias
                    pueden usarse igualmente para cualquier migraci√≥n,
                    sea de c√≥digo, de datos o de infraestructura. Las
                    bases de datos son un ejemplo protot√≠pico de
                    arquitectura cliente/servidor, as√≠ que nos dan un
                    marco de referencia bastante s√≥lido sobre el que
                    analizar cada estrategia.</p>
                    <p>La lista no es exhaustiva: seguramente el lector
                    pueda imaginar algunas estrategias adicionales y
                    perfectamente √∫tiles. Puedes compartirlas al final
                    del art√≠culo.</p>
                    <p>Ilustraremos las estrategias relevantes con
                    ejemplos de c√≥digo de Node.js, la plataforma que
                    usamos en MediaSmart Mobile. Es f√°cil de transcibir
                    a Java, PHP o a cualquier otro lenguaje porque el
                    c√≥digo es todo muy sencillo.</p>
                    <h1
                    id="cat√°logo-de-estrategias-de-servidor">Cat√°logo de
                    estrategias de servidor</h1>
                    <p>En esta primera categor√≠a tenemos estrategias que
                    se implementan puramente en el servidor, sin tener
                    que modificar el cliente salvo para
                    reconfigurarlo.</p>
                    <h2 id="parar-y-arrancar">Parar y arrancar</h2>
                    <figure>
                    <img src="pics/stop-migrate.png"
                    alt="Stop and migrate" />
                    <figcaption aria-hidden="true">Stop and
                    migrate</figcaption>
                    </figure>
                    <p>√âsta es la migraci√≥n de toda la vida:</p>
                    <ul>
                    <li>se para el sistema,</li>
                    <li>se copia la base de datos antigua a la nueva
                    (copia en fr√≠o),</li>
                    <li>se reconfiguran los clientes para que apunten a
                    la nueva,</li>
                    <li>y se vuelve a arrancar el sistema.</li>
                    </ul>
                    <p>Simple, ¬øno?</p>
                    <h3 id="reversible-no">Reversible: no</h3>
                    <p>Esta estrategia requiere dejar de dar servicio,
                    con lo que no es apropiada para situaciones de alta
                    disponibilidad.</p>
                    <p>La vuelta atr√°s consiste en volver a parar el
                    sistema, copiar la copia a la inversa, reconfigurar
                    y arrancar.</p>
                    <p>Claramente no es realmente reversible, y adem√°s
                    es un poco chapucera. ¬øOs imagin√°is la fiabilidad
                    que le da a un usuario encontrarse una web
                    ca√≠da?</p>
                    <h3 id="c√≥digo-de-ejemplo">C√≥digo de ejemplo</h3>
                    <p>El c√≥digo de servidor es muy sencillo. Primero
                    tenemos un fichero <code>settings.js</code> que
                    almacena la configuraci√≥n:</p>
                    <pre><code>module.exports = {
    redisAddress: &#39;redis.mydomain.com&#39;,
};</code></pre>
                    <p>El fichero intermedio <code>db.js</code> define
                    las bases de datos que usaremos, en este caso
                    <code>current</code>:</p>
                    <pre><code>var settings = require(&#39;./settings.js&#39;);
module.exports = {
    current: new RedisAdapter(settings.redisAddress),
};</code></pre>
                    <p>Finalmente, en cada sitio donde usemos la base de
                    datos accederemos a<code>db.current</code>:</p>
                    <pre><code>var db = require(&#39;./db.js&#39;);
db.current.get(key, function(error, result) {
    ...
});</code></pre>
                    <p>Para cambiar el acceso, s√≥lo tenemos que parar,
                    migrar, cambiar <code>settings.js</code> y arrancar
                    de nuevo.</p>
                    <blockquote>
                    <h4 id="caso-pr√°ctico-vpc-en-mediasmart-mobile">Caso
                    pr√°ctico: VPC en MediaSmart Mobile</h4>
                    <p>El primer caso pr√°ctico que vamos a ver no es
                    precisamente una migraci√≥n de base de datos. En
                    MediaSmart Mobile necesit√°bamos migrar nuestra
                    infraestructura en la nube de Amazon (AWS), de una
                    conexi√≥n no segura a la VPC (<em>Virtual Private
                    Cloud</em>).</p>
                    <p>El 3 de marzo de 2015 realizamos la migraci√≥n:
                    primero creamos una r√©plica de todos los servidores
                    en la VPC. A continuaci√≥n paramos los servidores
                    originales, y copiamos los datos a la VPC. Luego
                    arrancamos los nuevos sevidores, y apuntamos el
                    servidor DNS hacia ellos. Tras algunas horas de
                    <em>downtime</em> est√°bamos arriba otra vez.</p>
                    <p>El d√≠a 5 de marzo nos reportaron problemas en
                    producci√≥n, por lo que tuvimos que deshacer la
                    migraci√≥n. Por fortuna hab√≠amos mantenido las
                    instancias antiguas, as√≠ que fue cuesti√≥n de parar,
                    volver a copiar los datos y arrancar otra vez. Por
                    iron√≠as de la vida, el problema no se resolvi√≥ con
                    esta migraci√≥n inversa, por lo que dedujimos que
                    ten√≠a otra causa. Curiosamente, una vez que nos
                    quitamos de enmedio la causa m√°s obvia (la
                    migraci√≥n), el problema real se hizo evidente de
                    inmediato: un fallo que no ten√≠a nada que ver, sino
                    que ven√≠a causado por un despliegue anterior.</p>
                    <p>El d√≠a 11 de marzo probamos de nuevo con la misma
                    t√©cnica, y de nuevo tras varias horas de
                    <em>downtime</em> la migraci√≥n estaba hecha. Como
                    operamos en dos regiones de AWS, todav√≠a ten√≠amos
                    que migrar la segunda regi√≥n, cosa que hicimos el
                    d√≠a 13 de marzo (viernes). Porque total, viernes 13:
                    ¬øqu√© pod√≠a salir mal? Y no somos supersticiosos.</p>
                    <p>La moraleja es algo poco intuitivo: el mayor
                    problema de hacer una migraci√≥n es muchas veces que
                    nos impide pensar claramente sobre los fallos del
                    sistema, ya que nos fijaremos m√°s en los posibles
                    efectos colaterales que en otro problema no
                    relacionado que tenemos delante. Es otro motivo para
                    tener una estrategia de migraci√≥n inversa que
                    devuelva el sistema a su estado inicial.</p>
                    <p>Y, una vez que tenemos la estrategia inversa,
                    tambi√©n es importante (y de nuevo contraintuitivo)
                    que lo mejor es no realizar la migraci√≥n inversa,
                    sino buscar las causas profundas de los
                    problemas.</p>
                    </blockquote>
                    <h2 id="versi√≥n-de-s√≥lo-lectura">Versi√≥n de s√≥lo
                    lectura</h2>
                    <figure>
                    <img src="pics/read-only-version.png"
                    alt="Read-only version" />
                    <figcaption aria-hidden="true">Read-only
                    version</figcaption>
                    </figure>
                    <p>Ahora veremos una estrategia ligeramente m√°s
                    sofisticada. Los pasos son:</p>
                    <ul>
                    <li>pasar a modo de s√≥lo lectura,</li>
                    <li>hacer una copia en caliente (mientras el sistema
                    est√° andando),</li>
                    <li>cambiar a la nueva base de datos,</li>
                    <li>y volver al modo de lectura/escritura.</li>
                    </ul>
                    <p>Mientras el sistema est√° en s√≥lo lectura se puede
                    acceder a los datos pero no modificarlos. De esta
                    forma nos aseguramos de que se pueda hacer la copia
                    en caliente: como los datos no cambian, no tenemos
                    que preocuparnos de que la copia est√© desfasada al
                    terminar.</p>
                    <p>Esto suele ser bastante mejor que una parada
                    completa. Pero no siempre es posible: ciertos
                    sistemas tienen que estar recogiendo datos nuevos
                    constantemente, as√≠ que dejarlos en s√≥lo lectura es
                    como tirarlos abajo.</p>
                    <p>Otro factor a tener en cuenta es que una copia en
                    caliente puede tardar bastante m√°s que en fr√≠o,
                    debido a los accesos constantes.</p>
                    <h3 id="reversible-no-1">Reversible: no</h3>
                    <p>La migraci√≥n inversa es f√°cil, en teor√≠a: pasar
                    de nuevo a s√≥lo lectura, copiar los datos en sentido
                    contrario y volver a usar la base de datos original.
                    Sin embargo, la copia inversa requiere trabajo
                    extra, incluso si la nueva base de datos es id√©ntica
                    a la antigua: habr√° que invertir el script de copia
                    adaptando las direcciones de las m√°quinas. Y no
                    hablemos ya si hay que hacer cualquier tipo de
                    conversi√≥n de formato.</p>
                    <p>Siempre podemos preparar la copia inversa como
                    parte de la preparaci√≥n para la migraci√≥n; de esta
                    forma estamos preparados para la migraci√≥n inversa.
                    Pero seguimos teniendo <em>downtime</em>, aunque sea
                    s√≥lo para las escrituras. De ah√≠ que una migraci√≥n
                    de este tipo no sea realmente reversible.</p>
                    <blockquote>
                    <h4 id="caso-pr√°ctico-migraciones-wordpress">Caso
                    pr√°ctico: Migraciones WordPress</h4>
                    <p>Esta t√©cnica es muy b√°sica: se aplica por ejemplo
                    a las <a
                    href="http://www.wpbeginner.com/plugins/how-to-put-your-wordpress-site-in-read-only-state-for-site-migrations-and-maintenance/">migraciones
                    de WordPress</a>, para no tener que preocuparse de
                    cambios mientras se migra.</p>
                    </blockquote>
                    <h2 id="sincronizaci√≥n">Sincronizaci√≥n</h2>
                    <figure>
                    <img src="pics/sync.png" alt="Synchronization" />
                    <figcaption
                    aria-hidden="true">Synchronization</figcaption>
                    </figure>
                    <p>Supongamos de nuevo que tenemos dos bases de
                    datos, la antigua y la nueva. Queremos que ambas
                    queden sincronizadas, de forma que podamos usar una
                    u otra. Los pasos para hacer esta sincronizaci√≥n
                    son:</p>
                    <ul>
                    <li>hacer una copia en caliente de la antigua a la
                    nueva,</li>
                    <li>sincronizar todas las escrituras de la antigua a
                    la nueva,</li>
                    <li>pasar a leer de la nueva (pero seguir
                    escribiendo en la antigua),</li>
                    <li>y finalmente pasar a escribir a la nueva.</li>
                    </ul>
                    <p>La sincronizaci√≥n se hace en este caso mediante
                    un mecanismo de servidor, que recoge todas las
                    escrituras y pasarlas a otro sistema. No siempre es
                    posible hacerlo: a veces la carga en el sistema
                    antiguo es demasiado grande, o puede que no haya
                    forma de fechar los cambios para extraer s√≥lo los
                    √∫ltimos, lo que har√≠a la sincronizaci√≥n total
                    demasiado costosa.</p>
                    <h3 id="reversible-s√≠">Reversible: s√≠</h3>
                    <p>En el lado positivo, los usuarios no notar√°n
                    ning√∫n <em>downtime</em> al acceder al sistema.</p>
                    <p>Adem√°s, la estrategia inversa es trivial: s√≥lo
                    hay que volver a cambiar los accesos a la base de
                    datos antigua, mientras sigamos escribiendo en ella
                    y no desconectemos el mecanismo de
                    sincronizaci√≥n.</p>
                    <p>Pero si ya no estamos sincronizando los cambios o
                    hemos pasado a escribir en la nueva, la cosa cambia:
                    la migraci√≥n inversa requiere entonces sincronizar
                    los datos en el sentido contrario. La sincronizaci√≥n
                    bidireccional a menudo es demasiado costosa como
                    para ser pr√°ctica. As√≠ que hay que tener cuidado de
                    seguir sincronizando hasta que estemos seguros de
                    que la migraci√≥n ha sido exitosa y no vamos a querer
                    revertirla nunca.</p>
                    <blockquote>
                    <h4
                    id="caso-pr√°ctico-estad√≠sticas-diarias-en-mediasmart-mobile">Caso
                    pr√°ctico: Estad√≠sticas diarias en MediaSmart
                    Mobile</h4>
                    <p>En MediaSmart Mobile almacenamos datos de
                    estad√≠sticas del d√≠a, conocidos internamente como
                    <em>daystats</em>, para su consulta posterior por
                    usuarios y clientes. Guardarlos todos en Redis nos
                    estaba causando costes ingentes, as√≠ que decidimos
                    migrarlos a Redshift para su consulta offline.</p>
                    <p>Esta base de datos para <em>data warehousing</em>
                    tiene muchas cosas buenas, pero no permite carga en
                    tiempo real. El proceso de carga en Redshift suele
                    ejecutarse cada d√≠a o cada hora; en nuestro caso
                    decidimos exportar d√≠as completos, por lo que los
                    √∫ltimos datos tienen que consultarse siempre en
                    Redis. El desarrollo no fue trivial: seg√∫n las
                    fechas pedidas hay que acceder a Redis para los
                    datos de los √∫ltimos d√≠as, acceder a Redshift (que
                    tiene un modelo de datos completamente distinto
                    basado en SQL) para el resto, acumular ambos juegos
                    de valores y presentarlos al usuario.</p>
                    <p>La parte positiva es que la migraci√≥n fue
                    completamente suave. En este caso, la sincronizaci√≥n
                    se mantiene siempre (disfrazada de carga de datos),
                    por lo que para dejar de usar la nueva base de datos
                    en Redshift s√≥lo tenemos que cambiar un par√°metro de
                    configuraci√≥n. As√≠ que cuando se reportaron bugs fue
                    trivial comparar ambos, y volver a la versi√≥n
                    anterior mientras se investigaba por qu√© no
                    funcionaban bien datos migrados.</p>
                    </blockquote>
                    <h2 id="copia-doble">Copia doble</h2>
                    <figure>
                    <img src="pics/double-copy.png" alt="Double copy" />
                    <figcaption aria-hidden="true">Double
                    copy</figcaption>
                    </figure>
                    <p>En este caso queremos copiar los datos en dos
                    tandas, una antes de cambiar el acceso y otra
                    despu√©s. Los pasos a seguir son los siguientes:</p>
                    <ul>
                    <li>realizar una copia en caliente mientras se
                    accede al sistema antiguo,</li>
                    <li>empezar a leer y escribir en el sistema
                    nuevo,</li>
                    <li>y realizar una segunda copia en caliente del
                    sistema viejo al nuevo.</li>
                    </ul>
                    <p>Es importante se√±alar que con esta estrategia
                    estamos durante un tiempo accediendo a una versi√≥n
                    antigua de los datos: cuando empezamos a usar el
                    sistema nuevo todav√≠a no se han copiado todos los
                    datos que han llegado mientras se hac√≠a la primera
                    copia.</p>
                    <p>Adem√°s, la segunda copia requiere de algoritmos
                    algo m√°s sofisticados que la primera: si un mismo
                    registro ha sido modificado durante la primera copia
                    en el sistema antiguo, y luego durante la segunda
                    copia en el sistema nuevo, hay que saber mezclar los
                    datos. Para hacerlo con garant√≠as tenemos que
                    trabajar siempre con modificaciones at√≥micas, lo que
                    puede resultar bastante inc√≥modo y llevar a
                    conflictos. En esencia es como una mezcla
                    (<em>merge</em>) de c√≥digo de dos ramas: ¬øc√≥mo
                    resolvemos los conflictos sin intervenci√≥n
                    humana?</p>
                    <p>Otra opci√≥n es ignorar una de las dos
                    actualizaciones y quedarse, digamos, con la √∫ltima
                    edici√≥n de los datos. O directamente sobrescribir
                    con la versi√≥n que estamos copiando.</p>
                    <p>Esta estrategia no es siempre factible: no
                    siempre tenemos el lujo de poder prescindir de los
                    √∫ltimos datos, aunque sea durante un tiempo; ni de
                    poder ignorar las actualizaciones que lleguen en un
                    momento poco oportuno. L√≥gicamente no es buena
                    estrategia para datos financieros, por ejemplo.</p>
                    <h3 id="reversible-realmente-no">Reversible:
                    realmente no</h3>
                    <p>En principio este tipo de migraci√≥n no tiene
                    <em>downtime</em> asociado, lo que podr√≠a hacernos
                    pensar que es reversible. Pero la migraci√≥n inversa
                    requiere de esfuerzo extra: es necesario hacer una
                    copia en sentido inverso para recuperar los √∫ltimos
                    cambios. O eso, o perder todos los datos que han
                    llegado al sistema nuevo.</p>
                    <p>En general, la ausencia de <em>downtime</em> es
                    condici√≥n necesaria, pero no suficiente, para la
                    reversibilidad. El √∫nico criterio realmente fiable
                    es estudiar la migraci√≥n inversa.</p>
                    <blockquote>
                    <h4
                    id="caso-pr√°ctico-perfiles-en-mediasmart-mobile">Caso
                    pr√°ctico: Perfiles en MediaSmart Mobile</h4>
                    <p>En nuestra empresa guardamos perfiles
                    anonimizados de usuarios, con informaci√≥n sobre qu√©
                    categor√≠as de contenido han visitado. Los perfiles
                    nos ayudan a centrar el targeting y conseguir
                    mejores respuestas.</p>
                    <p>Cuando ten√≠amos unos 500 millones de perfiles
                    toda la informaci√≥n estaba guardada en Redis, que
                    necesita tener todos los datos en memoria. As√≠ que
                    en cierto momento decidimos moverlo todo a DynamoDB,
                    que tambi√©n responde muy r√°pido y tiene capacidad
                    ilimitada. Cuando lleg√≥ el momento de la migraci√≥n
                    nos dimos cuenta de que copiar los perfiles llevaba
                    m√°s de un d√≠a. Pero cont√°bamos con la ventaja de que
                    en realidad no pasa nada si se pierden unos cuantos
                    perfiles‚Ä¶ o unos cuantos millones. Tampoco pasa nada
                    si un perfil no se actualiza con los √∫ltimos
                    cambios, sigue siendo valioso.</p>
                    <p>As√≠ que nos decidimos por una copia doble.
                    Primero copiamos los perfiles a DynamoDB, tarea que
                    nos llev√≥ dos d√≠as, y empezamos a usar esta nueva
                    base de datos desde un solo servidor de prueba.
                    Cuando est√°bamos contentos con el resultado
                    cambiamos el resto de servidores. En este punto
                    volvimos a hacer una copia de los perfiles para
                    recoger los cambios que hab√≠an entrado durante las
                    pruebas. Cuando hab√≠a dos versiones del mismo
                    perfil, pod√≠amos elegir si quedarnos con la de Redis
                    o la de DynamoDB; realmente s√≥lo perder√≠amos una
                    peque√±a cantidad de informaci√≥n.</p>
                    <p>La migraci√≥n fue realmente suave. La vuelta atr√°s
                    trivial habr√≠a conllevado usar la base de datos
                    antigua, lo que podr√≠a haber supuesto perder
                    informaci√≥n de d√≠as o semanas; por suerte no tuvimos
                    que usarla. A d√≠a de hoy tenemos m√°s de mil millones
                    de perfiles, y creciendo.</p>
                    </blockquote>
                    <h1 id="cat√°logo-de-estrategias-en-cliente">Cat√°logo
                    de estrategias en cliente</h1>
                    <p>Como ya hemos visto, en una migraci√≥n conviene
                    separar acceso y datos. Ahora vamos a ver algunas
                    estrategias que modifican el acceso a los datos,
                    modificando el cliente en lugar del servidor.</p>
                    <p>Hemos elegido estrategias en cliente que sean
                    reversibles, aunque es necesario que la estrategia
                    del servidor sea tambi√©n reversible.</p>
                    <h2 id="adaptador">Adaptador</h2>
                    <p>Esta estrategia de cliente es la que nos permite
                    cambiar r√°pidamente de una base de datos a otra,
                    cuando son diferentes. Podemos ‚Äúdisfrazar‚Äù una base
                    de datos para que aparente ser otra usando el patr√≥n
                    cl√°sico de adaptador, y luego configurar a qu√© base
                    de datos accedemos.</p>
                    <h3 id="c√≥digo-de-ejemplo-1">C√≥digo de ejemplo</h3>
                    <p>El driver de Memcached es muy sencillo, tiene dos
                    funciones b√°sicas:</p>
                    <p>Para hacer un adaptador para Redis, simulamos la
                    interfaz de Memcached:</p>
                    <pre><code>var redis = require(&#39;redis&#39;);

exports.RedisAdapter = function(port, host) {
    // self-reference
    var self = this;
        
    // attributes
    var client = redis.createClient(port, host);

    self.get = function(key, callback) {
        client.get(key, function(error, result) {
            if (error) return callback(&#39;Could not get &#39; + key + &#39;:&#39; + error);
            return callback(null, JSON.parse(result));
    });

    self.set = function(key, value, callback) {
        return client.set(key, JSON.stringify(value), callback);
    });
};</code></pre>
                    <p>Para crear el driver s√≥lo tenemos que fijarnos en
                    si se trata de una direcci√≥n que empiece por
                    <code>redis:</code> o de una direcci√≥n
                    tradicional:</p>
                    <pre><code>var MemcachedAdapter = require(&#39;./memcached.js&#39;).MemcachedAdapter;
var RedisAdapter = require(&#39;./redis.js&#39;).RedisAdapter;
var settings = require(&#39;./settings.js&#39;);

var db = {
    main: getAdapter(settings.MAIN_DB_ADDRESS),
};

function getAdapter(address) {
    if (address.indexOf(&#39;redis:&#39;) === 0) {
        var redisAddress = address.substringFrom(&#39;:&#39;);
        var host = redisAddress.substringUpTo(&#39;:&#39;);
        var port = redisAddress.substringFrom(&#39;:&#39;);
        return new RedisAdapter(host, port);
    } else {
        return new MemcachedAdapter(address);
    }
}</code></pre>
                    <p>Y luego al usar el driver no tenemos que
                    preocuparnos de si estamos hablando con Redis o con
                    Memcached:</p>
                    <pre><code>db.main.get(&#39;hi&#39;, function(error, result) {
    if (error) return console.error(&#39;Got error: %s&#39;, error);
    console.log(&#39;Got result %j&#39;, result);
};</code></pre>
                    <blockquote>
                    <h4
                    id="caso-pr√°ctico-memcached-en-mediasmart-mobile">Caso
                    pr√°ctico: Memcached en MediaSmart Mobile</h4>
                    <p>En MediaSmart empezamos usando Couchbase, una
                    base de datos clave-valor enriquecida con una
                    historia curiosa.</p>
                    </blockquote>
                    <blockquote>
                    <p>La base de datos Memcached original se <a
                    href="https://en.wikipedia.org/wiki/Memcached#History">cre√≥
                    en 2003</a> por Brad Fitzpatrick para LiveJournal.
                    Era b√°sicamente una capa de cacheo: una base de
                    datos clave-valor que guarda todo en memoria.
                    Membase se cre√≥ como una base de datos con una
                    interfaz 100% compatible, pero capaz de guardar los
                    datos en disco. M√°s tarde CouchDB y Membase se
                    unieron para crear Couchbase, manteniendo la
                    interfaz de Membase, compatible a su vez con
                    Memcached.</p>
                    <p>Durante un tiempo Couchbase aguant√≥ bien, aunque
                    requer√≠a demasiado mantenimiento y el rendimiento se
                    fue degradando. Cuando los tiempos de respuesta
                    empezaron a ser alarmantes, nos planteamos pasar a
                    Redis: otra base de datos clave-valor con
                    persistencia a disco. El problema es que el driver
                    era algo diferente: para empezar necesitaba recibir
                    siempre texto en lugar de admitir objetos y
                    convertirlos a JSON √©l mismo.</p>
                    <p>Tras crear el adaptador, era cosa sencilla elegir
                    si us√°bamos Memcached o Redis para cada instancia de
                    base de datos.</p>
                    </blockquote>
                    <h2 id="consulta-dual">Consulta dual</h2>
                    <figure>
                    <img src="pics/dual-lookup.png" alt="Dual lookup" />
                    <figcaption aria-hidden="true">Dual
                    lookup</figcaption>
                    </figure>
                    <p>Esta t√©cnica es muy sencilla: empezamos a
                    escribir en la nueva base de datos, y a la hora de
                    leer leemos de ambas: primero miramos en la nueva, y
                    si no est√°, tiramos de la antigua.</p>
                    <p>La migraci√≥n de datos en el servidor se puede
                    hacer con una sencilla copia en caliente.</p>
                    <p>El problema m√°s obvio es que el tiempo de lectura
                    se duplica, cosa que no siempre es aceptable.</p>
                    <p>Tambi√©n puede ser un problema si las claves se
                    pueden borrar: con esta estrategia estaremos dando
                    por bueno un valor de la base de datos antigua que
                    ya no existe en la nueva. En este caso es
                    recomendable usar otra estrategia, aunque tambi√©n se
                    puede usar un valor <code>null</code> que indique
                    que la clave est√° vac√≠a.</p>
                    <h3 id="c√≥digo-de-ejemplo-2">C√≥digo de ejemplo</h3>
                    <p>La clase de acceso es tan sencilla como esto:</p>
                    <pre><code>exports.db = {
    v1: new RedisAdapter(settings.oldRedis),
    v2: new RedisAdapter(settings.newRedis),
};</code></pre>
                    <p>y el cliente s√≥lo tiene que hacer:</p>
                    <pre><code>function get(key, callback) {
    db.v2.get(key, function(error, result) {
        if (error || result) callback(error, result);
        db.v1.get(key, callback);
    });
}</code></pre>
                    <h2 id="escritura-dual">Escritura dual</h2>
                    <figure>
                    <img src="pics/dual-write.png" alt="Dual write" />
                    <figcaption aria-hidden="true">Dual
                    write</figcaption>
                    </figure>
                    <p>Esta t√©cnica es similar a la anterior, pero en
                    lugar de leer de dos sitios, escribimos a dos
                    sitios.</p>
                    <p>La escritura dual sirve para mantener dos
                    servidores sincronizados despu√©s de haber pasado de
                    usar uno al otro.</p>
                    <p>En este caso la latencia a√±adida puede no ser un
                    problema, siempre que las escrituras se realicen de
                    forma as√≠ncrona tras terminar de procesar las
                    peticiones. En el caso de que requiramos
                    confirmaci√≥n de escritura en ambas bases de datos la
                    latencia aumentar√°.</p>
                    <blockquote>
                    <h4 id="caso-pr√°ctico-backup-en-ing">Caso pr√°ctico:
                    Backup en ING</h4>
                    <p>Por requerimientos del Banco de Espa√±a, un banco
                    debe almacenar sus datos al menos en dos centros de
                    datos separadas por suficiente distancia. En el
                    banco ING se mantienen dos centros de datos en dos
                    ciudades distintas: uno primario y otro secundario,
                    ambos con la capacidad suficiente como para dar
                    servicio a todos los clientes. En caso de cat√°strofe
                    se pasa a usar el secundario.</p>
                    <p>Hace unos a√±os se pas√≥ de tener una r√©plica en
                    caliente a una r√©plica online: todas las escrituras
                    deb√≠an confirmarse en ambos centros antes de darse
                    por finalizadas. De esta forma se tiene la garant√≠a
                    de que los datos son iguales en ambos centros, y se
                    puede pasar de uno a otro a voluntad.</p>
                    </blockquote>
                    <h2 id="paso-temporizado">Paso temporizado</h2>
                    <figure>
                    <img src="pics/timed-rollover.png"
                    alt="Timed rollover" />
                    <figcaption aria-hidden="true">Timed
                    rollover</figcaption>
                    </figure>
                    <p>En este caso el cliente usar√° un servidor u otro
                    dependiendo de los datos a acceder, con una fecha de
                    corte configurable.</p>
                    <p>El resultado es un cambio suave de servidores, a
                    costa de a√±adir como mucho unos pocos microsegundos
                    (¬µs) a cada query.</p>
                    <h3 id="c√≥digo-de-ejemplo-3">C√≥digo de ejemplo</h3>
                    <p>Un objeto se usa para recubrir dos alternativas,
                    y se selecciona la adecuada seg√∫n la fecha
                    actual.</p>
                    <pre><code>var Memcached = require(&#39;memcached&#39;);

exports.CleverAdapter = function(name, address) {
    // self-reference
    var self = this;
    
    // attributes
    var oldAdapter = new Memcached(address + &#39;:11211&#39;);
    var newAdapter = new RedisAdapter(address);
        
    self.get = function(key, callback) {
        if (new Date().toISOString() &lt; &#39;2015-11-14&#39;) {
            return oldAdapter.get(key, callback);
        }
        return newAdapter.get(key, callback);
    }
};</code></pre>
                    <blockquote>
                    <h4
                    id="caso-pr√°ctico-agregados-en-mediasmart-mobile">Caso
                    pr√°ctico: Agregados en MediaSmart Mobile</h4>
                    <p>De nuevo usaremos las estad√≠sticas diarias
                    (<em>daystats</em>) que se pueden consultar en el
                    pasado.</p>
                    </blockquote>
                    <blockquote>
                    <p>En cierto momento las consultas empezaron a ir
                    demasiado lentas, as√≠ que a√±adimos agregados que se
                    actualizan autom√°ticamente y que nos evitan leer
                    muchas claves a la vez para conseguir un solo
                    resultado. A partir de cierto momento empezamos a
                    guardar estos agregados. Pero nos quer√≠amos ahorrar
                    hacer un proceso batch que se recorriera todos los
                    d√≠as anteriores y calculara los agregados, as√≠ que
                    simplemente pusimos como fecha de corte el d√≠a
                    posterior a activar los agregados: si la consulta
                    era posterior a este d√≠a se usar√≠an los agregados, y
                    si no, har√≠amos la consulta habitual.</p>
                    <p>Sencillo y elegante, y que nos ahorr√≥ un mont√≥n
                    de trabajo.</p>
                    </blockquote>
                    <h2 id="conversi√≥n-in-situ">Conversi√≥n <em>in
                    situ</em></h2>
                    <figure>
                    <img src="pics/in-place.png"
                    alt="In-place conversion" />
                    <figcaption aria-hidden="true">In-place
                    conversion</figcaption>
                    </figure>
                    <p>Queremos cambiar el formato de los valores de un
                    cierto tipo. En lugar de recorrer todos los valores
                    existentes y modificarlos, podemos empezar a
                    escribir los valores nuevos con este nuevo formato,
                    e ir modificando los antiguos seg√∫n se leen.</p>
                    <p>La lectura de cualquier valor consta de los
                    siguientes pasos:</p>
                    <ul>
                    <li>Leer el valor.</li>
                    <li>Si tiene el formato nuevo, devolverlo tal
                    cual.</li>
                    <li>Si tiene el formato antiguo, convertirlo al
                    nuevo formato y guardarlo de nuevo.</li>
                    <li>Devolver el valor resultante de la
                    conversi√≥n.</li>
                    </ul>
                    <p>La migraci√≥n de formato se va haciendo poco a
                    poco seg√∫n se van leyendo valores. En un momento
                    dado podemos hacer un repaso a todos los registros
                    restantes, ley√©ndolos y convirti√©ndolos en su sitio.
                    En cualquier caso nos hemos evitado hacer la
                    migraci√≥n de formatos de un golpe.</p>
                    <p>En esta conversi√≥n no hay sistema antiguo y
                    nuevo: s√≥lo hay un sistema. Es un caso ‚Äúdegenerado‚Äù
                    de las migraciones que hemos visto hasta ahora.
                    Tambi√©n es especial porque no hay parte de servidor:
                    toda la migraci√≥n se hace en el cliente.</p>
                    <p>Esta migraci√≥n es adecuada para cambios internos
                    en la estructura de cada registro, no para
                    modificaciones de estructura en bases de datos SQL
                    que s√≠ tienen que hacerse de un golpe.</p>
                    <h3 id="c√≥digo-de-ejemplo-4">C√≥digo de ejemplo</h3>
                    <p>El cliente lee un registro en el que la fecha
                    puede estar en formato num√©rico o como cadena en
                    formato ISO. Lo queremos siempre como cadena, as√≠
                    que si es un n√∫mero lo convertimos a cadena y lo
                    volvemos a guardar. En cualquier caso se lo pasamos
                    a la callback con el formato de cadena esperado.</p>
                    <pre><code>function getValue(key, callback)
{
    db.get(key, function(error, value)
    {
        if (error) return callback(error);
        if (typeof value.timestamp == &#39;number&#39;)
        {
            value.timestamp = new Date(value.timestamp).toISOString();
            db.set(key, value, function(error)
            {
                if (error) log.error(&#39;Could not store value: %s&#39;, error);
            });
        }
        return callback(null, value);
    });
}</code></pre>
                    <blockquote>
                    <h4
                    id="caso-pr√°ctico-compresi√≥n-de-perfiles-en-mediasmart-mobile">Caso
                    pr√°ctico: Compresi√≥n de perfiles en MediaSmart
                    Mobile</h4>
                    <p>Volvemos a encontrarnos con los perfiles de
                    MediaSmart Mobile. En cierto momento encontramos que
                    ten√≠amos ya m√°s de 100 millones de perfiles, y que
                    ocupaban demasiado espacio. (Era antes de la
                    migraci√≥n a DynamoDB, y en Redis se almacena todo en
                    memoria.) As√≠ que decidimos comprimir los perfiles
                    m√°s habituales para reducir el espacio usado.</p>
                    <p>Cada perfil consta de una serie de valores que
                    tienden a repetirse, como el rango de edades o las
                    categor√≠as visitadas previamente. Para comprimir los
                    perfiles decidimos tomar los valores m√°s comunes y
                    codificarlos con un formato especial que nos
                    permitiera reconocer que se trataba de un valor
                    codificado. El perfil resultante ocupaba bastante
                    menos que el original, pero una vez m√°s quer√≠amos
                    evitar una migraci√≥n a gran escala.</p>
                    <p>As√≠ que decidimos hacer una conversi√≥n <em>in
                    situ</em>: al leer los perfiles ten√≠amos que
                    descomprimirlos en cualquier caso, as√≠ que
                    aprovechamos la circunstancia para ir guard√°ndolos
                    comprimidos seg√∫n se iban leyendo y modificando. En
                    el proceso nos ahorramos varios cientos de GB de
                    datos.</p>
                    </blockquote>
                    <h1 id="cat√°logo-de-estrategias-en-broker">Cat√°logo
                    de estrategias en broker</h1>
                    <p>A continuaci√≥n vamos a ver un par de estrategias
                    que dependen de una m√°quina intermedia entre el
                    cliente y el servidor, a la que vamos a llamar
                    ‚Äúbroker‚Äù.</p>
                    <p>De nuevo estas estrategias suelen requerir una
                    migraci√≥n en el servidor paralela, as√≠ que tampoco
                    investigaremos si son reversibles o no. Dado que son
                    similares a las estrategias en cliente tampoco
                    veremos casos pr√°cticos; s√≥lo las mencionamos de
                    pasada.</p>
                    <h2 id="acceso-mediante-proxy">Acceso mediante
                    proxy</h2>
                    <figure>
                    <img src="pics/proxied-access.png"
                    alt="Proxied access" />
                    <figcaption aria-hidden="true">Proxied
                    access</figcaption>
                    </figure>
                    <p>El broker es en este caso un proxy, que env√≠a las
                    consultas a un servidor o a otro seg√∫n un valor de
                    configuraci√≥n. El cliente no tiene que preocuparse
                    de enviar las consultas al servidor correcto; el
                    broker se ocupa de todo.</p>
                    <p>El problema m√°s evidente es que a√±adimos tiempo a
                    la consulta, y adem√°s un nuevo punto de fallo.</p>
                    <h3 id="c√≥digo-de-ejemplo-5">C√≥digo de ejemplo</h3>
                    <p>El proxy tiene a la vez un servidor y un
                    cliente.</p>
                    <pre><code>const http = require(&#39;http&#39;);
const request = require(&#39;basic-request&#39;);

http.createServer((request, response) =&gt; {
    const url = &#39;http://newserver.com&#39; + req.path;
    request.get(url, function(error, body)
    {
        if (error)
        {
            response.writeHead(500);
            response.end(&#39;Could not reach 
            return;
        }
        response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/plain&#39; });
        response.end(body);
    });
}).listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});</code></pre>
                    <h2 id="escritura-en-cola">Escritura en cola</h2>
                    <figure>
                    <img src="pics/queued-write.png"
                    alt="Queued write" />
                    <figcaption aria-hidden="true">Queued
                    write</figcaption>
                    </figure>
                    <p>En este caso no escribimos directamente en
                    destino, sino que almacenamos las escrituras y las
                    hacemos todas de golpe.</p>
                    <p>Es muy com√∫n en los servidores de base de datos
                    (por ejemplo <a
                    href="http://docs.couchbase.com/admin/admin/Monitoring/monitor-diskqueue.html">Couchbase</a>)
                    agrupar las escrituras para ahorrar procesamiento.
                    En nuestro caso podemos enviar las escrituras al
                    servidor que convenga para nuestra migraci√≥n.</p>
                    <h2 id="migraci√≥n-de-cualquier-tipo">Migraci√≥n de
                    cualquier tipo</h2>
                    <figure>
                    <img src="pics/all.png" alt="All strategies" />
                    <figcaption aria-hidden="true">All
                    strategies</figcaption>
                    </figure>
                    <p>Todas las estrategias que hemos visto son √∫tiles
                    no s√≥lo para migraciones de base de datos. En lugar
                    de copiar datos es posible que tengamos que copiar
                    configuraciones, c√≥digo o ficheros planos. En
                    cualquier caso tendremos que ocuparnos de dos cosas:
                    migrar los accesos, y mover la informaci√≥n
                    necesaria. Cada parte puede resolverse de forma
                    separada, lo que nos da dos grados de libertad que
                    nos pueden ayudar en nuestro trabajo.</p>
                    <p>En cualquier migraci√≥n querremos evitar tener
                    <em>downtime</em>, no s√≥lo por no molestar a
                    nuestros clientes: por orgullo, y porque dejar de
                    dar servicio es mala ingenier√≠a.</p>
                    <blockquote>
                    <h3
                    id="caso-pr√°ctico-migraci√≥n-de-instagram-a-facebook">Caso
                    pr√°ctico: Migraci√≥n de Instagram a Facebook</h3>
                    <p>Tras la compra de Instagram, Facebook ten√≠a
                    l√≥gicamente inter√©s en que se usaran sus centros de
                    datos. Instagram se embarc√≥ en una migraci√≥n de
                    dimensiones √©picas, y tuvo a bien documentarla en su
                    <a
                    href="http://instagram-engineering.tumblr.com/post/89992572022/migrating-aws-fb">blog
                    de ingenier√≠a</a>. Se trataba de migrar miles de
                    instancias, y como buenos ingenieros se plantearon
                    hacerla <em>sin p√©rdida de servicio</em>.</p>
                    <p>El proceso llev√≥ un a√±o completo, de 2013-04 a
                    2014-04. El primer paso fue migrar a AWS VPC, la red
                    privada virtual de Amazon. Este paso era necesario
                    para evitar colisiones de direcciones IP ya que
                    Facebook usa el mismo espacio privado que AWS.</p>
                    <p>As√≠ que decidieron crear Neti: un servicio de
                    manipulaci√≥n de tablas de IPs din√°micas que permit√≠a
                    compatibilizar los accesos a m√°quinas, sin importar
                    si residen en VPC o en la red cl√°sica. √âsta
                    herramienta permit√≠a configurar cada servidor para
                    funcionar La migraci√≥n a VPC llev√≥ tres semanas.</p>
                    <p>A partir de ah√≠, la migraci√≥n de VPC a Facebook
                    llev√≥ otras dos semanas adicionales. Las
                    herramientas de gesti√≥n de Instagram
                    (provisionamiento de servidores) se ampliaron para
                    funcionar tanto en AWS como en el entorno de
                    Facebook.</p>
                    <p>Todo esto para un esfuerzo planteado como
                    migraci√≥n m√≠nima.</p>
                    </blockquote>
                    <h1 id="sigue-fluyendo">Sigue fluyendo</h1>
                    <p>Hay otros aspectos de las migraciones que
                    considerar antes de despedirnos.</p>
                    <h2 id="minimizando-los-errores">Minimizando los
                    errores</h2>
                    <p>El aspecto que m√°s miedo da de cualquier
                    migraci√≥n es probablemente tener un error grave: en
                    estas circunstancias es f√°cil dejar de dar servicio
                    o incluso perder gran cantidad de datos.</p>
                    <h3 id="el-equilibrio-inestable">El equilibrio
                    inestable</h3>
                    <p>Un sistema que fluye se mantiene en equilibrio,
                    pero no es necesariamente un equilibrio estable.</p>
                    <blockquote>
                    <h3 id="caso-pr√°ctico-punto-neutro">Caso pr√°ctico:
                    Punto neutro</h3>
                    <p>Veamos un ejemplo sacado de una ingenier√≠a
                    completamente diferente a la nuestra: la
                    aerodin√°mica. Los <a
                    href="http://aviation.stackexchange.com/a/8061/12166">aviones
                    supers√≥nicos</a> tienen que funcionar en dos
                    reg√≠menes completamente diferentes: primero tienen
                    que volar en modo subs√≥nico, y una vez que alcanzan
                    la velocidad del sonido pasan al modo supers√≥nico.
                    Esto causa un problema: el centro de gravedad est√°
                    por detr√°s del punto neutro, lo que hace que el
                    vuelo sea inestable. La √∫nica forma de mantenerlos
                    en el aire sin que se desintegren es corregir la
                    trayectoria con un ordenador de a bordo, sin el cual
                    el vuelo ser√≠a completamente imposible.</p>
                    <p>(Los aviones acrob√°ticos tambi√©n son
                    inherentemente inestables, lo que los hace m√°s
                    manejables, pero al volar a menos velocidad es
                    posible que un piloto los controle.)</p>
                    </blockquote>
                    <h3 id="velocidad-de-crucero">Velocidad de
                    crucero</h3>
                    <p>Un sistema que fluye demasiado despacio se vuelve
                    tambi√©n dif√≠cil de manejar, lo que podemos
                    contrarrestar aumentando la velocidad del cambio.
                    Pero en este caso el sistema se vuelve inestable, y
                    hay que controlarlo para que los fallos que van
                    surgiendo no se acumulen.</p>
                    <p>La velocidad de crucero √≥ptima es la que nos
                    permite realizar cambios al sistema de la forma m√°s
                    r√°pida, sin comprometer la integridad del
                    sistema.</p>
                    <h3 id="seguridad-por-defecto">Seguridad por
                    defecto</h3>
                    <p>La mejor forma de intentar evitar errores es
                    tener <em>secure defaults</em>: que la forma de
                    operaci√≥n por defecto sea segura.</p>
                    <p>La monitorizaci√≥n activa es la primera l√≠nea de
                    defensa: un sistema que env√≠e notificaciones a los
                    administradores. Pero no podemos quedarnos ah√≠. El
                    ejemplo m√°s t√≠pico es el <a
                    href="https://es.wikipedia.org/wiki/Hombre_muerto">dispositivo
                    de hombre muerto</a>: un mecanismo que detiene el
                    tren si el maquinista no lo pisa cada cierto
                    tiempo.</p>
                    <p>Otro ejemplo cl√°sico es el <a
                    href="http://cincodays.com/2014/02/19/conociendo-la-historia-animales-en-la-historia-los-canarios-en-las-minas-de-carbon/">canario</a>
                    que se introduc√≠a en la mina de carb√≥n para que
                    avisara de cualquier fuga de gases venenosos. En
                    nuestro caso, lo ideal es conectar el canario con el
                    dispositivo de hombre muerto para que nuestro
                    sistema vuelva a la operaci√≥n segura por s√≠ solo
                    ante cualquier problema.</p>
                    <blockquote>
                    <h4
                    id="caso-pr√°ctico-parada-de-bidding-en-mediasmart">Caso
                    pr√°ctico: Parada de bidding en MediaSmart</h4>
                    <p>En MediaSmart hemos tenido unos cuantos problemas
                    serios con el sistema de bidding autom√°tico que nos
                    han causado p√©rdidas monetarias. En una startup
                    espa√±ola el dinero no suele sobrar, as√≠ que siempre
                    que nos hemos encontrado con problemas serios hemos
                    buscado formas de operaci√≥n seguras.</p>
                    </blockquote>
                    <blockquote>
                    <p>Actualmente, aparte de m√∫ltiples notificaciones
                    de condiciones an√≥malas, hemos optado por parar el
                    bidding preventivamente antes que perder dinero.
                    Varios de nuestros ‚Äúcanarios‚Äù son capaces de parar
                    el bidding de forma aut√≥noma para que el sistema no
                    siga pujando, ante cualquier s√≠ntoma de alarma. La
                    vuelta a la normalidad se hace tambi√©n de forma
                    autom√°tica, salvo en casos extremos que requieran de
                    revisi√≥n manual.</p>
                    </blockquote>
                    <h3 id="vivir-con-errores">Vivir con errores</h3>
                    <p>Cuando estamos haciendo tareas delicadas es
                    inevitable que, m√°s tarde o m√°s temprano, cometamos
                    un error. Todas nuestras medidas de seguridad s√≥lo
                    nos ayudan a evitar problemas pasados, pero es
                    dif√≠cil precaverse de todos los problemas futuros.
                    La √∫nica forma de no meter la pata es no hacer nada,
                    nunca. Si decidimos seguir este camino nos
                    quedaremos con una arquitectura r√≠gida y dif√≠cil de
                    cambiar.</p>
                    <p>Por suerte, la forma m√°s segura de operar es
                    adem√°s la que m√°s nos conviene: una migraci√≥n
                    reversible, donde sea tan f√°cil ir hacia atr√°s como
                    hacia adelante. El precio a pagar es que, de vez en
                    cuando, cometeremos errores. Hay que aceptarlo y
                    seguir hacia adelante.</p>
                    <p>Entre tanta migraci√≥n, no hay que perder de vista
                    el objetivo final: tener una arquitectura flexible y
                    que pueda adaptarse a las nuevas circunstancias
                    r√°pidamente. En el entorno moderno una arquitectura
                    que no es capaz de amoldarse a las nuevas
                    circunstancias est√° obsoleta desde antes de probar
                    su val√≠a en producci√≥n.</p>
								</div>
							</section>
							<section id="last">
								<div class="container">
									<p>
									Publicado originalmente en <a
         href="http://www.todojs.com/tras-la-arquitectura-perfecta-la-arquitectura-fluida-parte-2/">TodoJS</a>
         el 2015-12-28.
									</p>
									<p>
									Back to the <a href="/">index</a>.
									</p>
								</div>
							</section>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<ul class="copyright">
								<li>
									¬© <a href="mailto:alexfernandeznpm@gmail.com">Alex Fern√°ndez</a>.
									<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
								</li>
								<li>Original design: <a href="http://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</section>

			</div>
	</body>
</html>
