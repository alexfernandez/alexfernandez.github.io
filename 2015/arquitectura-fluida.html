<!DOCTYPE HTML>
<!--
	Read Only by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>La arquitectura fluida</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="stylesheet" href="../css/main.css" />
		<!--[if lte IE 8]><link rel="stylesheet" href="../css/ie8.css" /><![endif]-->
	</head>
	<body>

		<!-- Header -->
			<section id="header">
				<header>
					<span class="image avatar"><a href="../index.html"><img src="../pics/avatar.jpg" alt="Avatar" /></a></span>
					<h1 id="logo"><a href="../index.html">Alex Fernández</a></h1>
					<p>
					I am a developer (little) known on Twitter as <a href="https://twitter.com/pinchito">pinchito</a>.
					</p>
				</header>
				<!--
				<nav id="nav">
					<ul>
						<li><a href="#one" class="active">About</a></li>
						<li><a href="#two">Things I Can Do</a></li>
						<li><a href="#three">A Few Accomplishments</a></li>
						<li><a href="#four">Contact</a></li>
					</ul>
				</nav>
				<footer>
					<ul class="icons">
						<li><a href="#" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
						<li><a href="#" class="icon fa-facebook"><span class="label">Facebook</span></a></li>
						<li><a href="#" class="icon fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="#" class="icon fa-github"><span class="label">Github</span></a></li>
						<li><a href="#" class="icon fa-envelope"><span class="label">Email</span></a></li>
					</ul>
				</footer>
				-->
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h1>La arquitectura fluida</h1>
										<p>O de cómo migrar sin penas<p>
									</header>
										<div class="figure">
<img src="pics/la-persistencia-de-la-memoria.jpg" title="La persistencia de la memoria" alt="Imagen: Salvador Dalí" /><p class="caption">Imagen: <a href="http://www.wikiart.org/en/salvador-dali/the-persistence-of-memory-1931">Salvador Dalí</a></p>
</div>
<h1 id="tras-la-arquitectura-perfecta">Tras la arquitectura perfecta</h1>
<p>En muchas empresas hay departamentos de arquitectura dedicados a decidir cómo se va a organizar cada proyecto de software. Deciden el diseño a alto nivel, en cuántas capas se dividirá, qué base de datos usar y otros detalles importantes.</p>
<p>¿Por qué cambiar la base de datos en cada proyecto? ¿Por qué no usamos siempre la misma? Para construir edificios no existe un material perfecto: a veces es mejor la piedra, otras el ladrillo y otras incluso el acero. Tampoco hay una forma perfecta para todos los edificios: cuadrados, rectángulos, cilindros y semiesferas se comportan de forma distinta bajo la carga. Lo mismo ocurre con los componentes de software: cada uno tiene unas restricciones operacionales diferentes, y se comporta mejor en ciertas circunstancias.</p>
<h3 id="qué-es-la-arquitectura">Qué es la arquitectura</h3>
<p>Puede que nos ayude a centrar la discusión si definimos qué es este negocio de &quot;arquitectura&quot; en software.</p>
<p>En esencia se trata de dividir el sistema en bloques (o componentes) de alto nivel, y organizar las relaciones entre ellos. La organización en componentes suele derivar en la organización física de las máquinas y la elección de lenguaje y programas auxiliares, como por ejemplo qué base de datos usar. De ahí vienen cosas como la arquitectura en tres capas que se popularizó hace años, o la moda más reciente de usar gestores de colas en sistemas escalables.</p>
<p>Curiosamente, nadie se fija en el diseño a alto nivel del propio software, por ejemplo: la división en módulos de npm o en librerías, cómo se dividen los servicios de una API en el código o qué hacer con el código compartido entre diferentes programas. Tampoco en asuntos más de DevOps como la forma de desplegar el código o la creación de entornos de integración. Así que nos limitaremos a considerar la organización en máquinas y qué software usar.</p>
<h3 id="modas-en-arquitectura">Modas en arquitectura</h3>
<p>En los años 80, la moda empresarial era tener una <a href="http://www.computerhistory.org/revolution/minicomputers/11/366/1946">minicomputadora</a> (del tamaño de un armario pequeño) y múltiples terminales conectados.</p>
<p>En los 90 se popularizaron las arquitecturas cliente-servidor. Se separaban así los programas servidor que generaban respuestas y las bases de datos que recogían la información. Poco después llegarían protocolos de comunicación entre servidores como CORBA y un poco más tarde <a href="https://en.wikipedia.org/wiki/XML#History">XML</a>.</p>
<p>A principios del siglo XXI llegaron las arquitecturas de tres capas: capa web, backend y base de datos. Era un refinamiento del paradigma cliente-servidor donde el servidor se dividía en un backend y un En elementos más blanditos, también se inventó el ridículo <a href="https://en.wikipedia.org/wiki/Enterprise_service_bus#History"><em>Enterprise Service Bus</em></a>, que empezó a infectar los diagramas corporativos allá por 2002.</p>
<p>En los años 10 las bases de datos NoSQL han adquirido protagonismo. Los servidores sin estado son de uso común, al igual que los gestores de colas.</p>
<p>En general, un sistema de software suele poder fecharse con bastante precisión sólo con ver la arquitectura que implementa. No deja de ser curioso que sea un asunto de modas, cuando hay tantos especialistas en las empresas grandes.</p>
<h2 id="requisitos-cambiantes">Requisitos cambiantes</h2>
<p>Un sistema de software tiene que poder evolucionar durante su vida útil. Esto significa responder a requisitos cambiantes sin excesivas remodelaciones.</p>
<h3 id="requisitos-funcionales">Requisitos funcionales</h3>
<p>Empecemos con una anécdota, en este caso con trasfondo militar. El avión bombardero <a href="http://www.af.mil/AboutUs/FactSheets/Display/tabid/224/Article/104465/b-52-stratofortress.aspx">B-52 <em>stratofortress</em></a> empezó a operar en 1952, las últimas unidades se construyeron en 1963, y actualmente sigue en servicio tras más de seis décadas de actualizaciones. Durante este tiempo se han actualizado para que usen motores turbofan, combustible alternativo, puedan lanzar armas nucleares y misiles inteligentes guiados, se han reparado <a href="https://en.wikipedia.org/wiki/Boeing_B-52_Stratofortress#Design">múltiples problemas estructurales</a>, mejorado la aviónica, y mejorado para proporcionar visión noctura a los pilotos. Se estima que podrá seguir en servicio activo al menos hasta 2040. En resumen: un bombardero diseñado durante la guerra de Corea y fabricado mientras JFK era presidente, seguirá en uso hasta dentro de 25 años.</p>
<p>Como ingenieros, nuestra mayor aspiración es seguramente que lo que construyamos dure en el tiempo. Para eso es necesario que pueda actualizarse y mejorarse con el tiempo, añadiendo nuevas funcionalidades según se necesiten. Tenemos la gran ventaja de que nuestros sistemas se pueden actualizar mientras están funcionando, gracias a la magia del software: basta con sacar una copia y trabajar sobre ella.</p>
<p>Así que nos resulta relativamente fácil que nuestro software haga cosas nuevas. ¿O no? Sólo tenemos que extenderlo más allá de su propósito general. Excepto cuando no se puede. Todos conocemos algún proyecto que ha pasado su fecha de expiración. Nadie quiere tocar el código porque se ha convertido en una masa siniestra de <em>spaghetti</em>, los cambios son inmanejables y cada vez que tocas en un sitio se rompe algo en otro aparentemente no relacionado.</p>
<p>Nuestra misión es mantener el software flexible, para que podamos seguir añadiendo funcionalidades. Eso lleva algún esfuerzo extra, sin duda, pero la recompensa es grande cuando el proyecto es realmente exitoso.</p>
<h3 id="requisitos-operacionales">Requisitos operacionales</h3>
<p>Las circunstancias en las que nuestro sistema tiene que trabajar cambian, para bien o para mal. Así que, sin añadir funcionalidades nuevas, necesitamos ampliar el rango operativo del sistema.</p>
<h4 id="planificación-de-capacidad">Planificación de capacidad</h4>
<p>Un caso importante es la planificación de la capacidad necesaria (lo que se conoce como <em>capacity planning</em>). Un producto exitoso a menudo dobla el número de usuarios en un año, o incluso en una mes: en 2013 <a href="http://techcrunch.com/2013/12/18/uber-lyft/">Uber</a> crecía al 400% por año, mientras que su competidora Lyft lo hacía a un ritmo todavía más vertiginoso que suponía multiplicar su facturación por 20 al año.</p>
<p>¿Es posible que el mismo sistema sea capaz de crecer para soportar todo el tráfico que le echemos? Si usamos la planificación de capacidad, seguramente intentaremos predecir el tráfico que vamos a tener durante todo el año en base a los datos del año anterior, para ir presupuestando el número de servidores que vamos a necesitar. También necesitaremos redimensionar todos nuestros componentes para aguantar el tráfico extra. Esto, que era práctica estándar hace unos años, ahora sería un suicidio: fácilmente la tasa de crecimiento puede ser exponencial, de forma que se doble cada poco tiempo.</p>
<p>¿Cómo predecir el tráfico que tendremos, no ya al final de un año, sino sólo dentro de un mes? Respuesta: no podemos. Sólo podemos intentar ir un paso por delante del tráfico, y no adelantar demasiado los acontecimientos.</p>
<h4 id="caso-práctico-mediasmart-mobile">Caso práctico: MediaSmart Mobile</h4>
<div class="figure">
<img src="pics/mediasmart-krps.jpg" alt="Peticiones por segundo en MediaSmart Mobile" /><p class="caption">Peticiones por segundo en MediaSmart Mobile</p>
</div>
<p>Esta gráfica muestra los picos de peticiones por segundo que hemos recibido en MediaSmart Mobile desde 2013. Durante el primer año el volumen fue creciendo linealmente, pasando de 2 a 12 krps (miles de peticiones por segundo). A principios de 2014 pasó algo curioso: el ritmo se aceleró, y pasamos de 15 a 100 krps durante ese año. Pero en 2015 el ritmo está decelerando de nuevo: apenas pasaremos de 210 krps antes de final de año.</p>
<p>Si a principios 2014 hubiéramos pintado una línea recta y hubiéramos intentado predecir el tráfico del año, habríamos calculado alrededor de 25 krps (definitivamente por debajo de 30 krps); a final de año teníamos 100 krps. Por otra parte, si hubiéramos seguido la curva exponencial para 2015, a final de año habríamos andado por 600 krps; la cifra real anda cerca de las 200 krps.</p>
<h4 id="costes-bajos">Costes bajos</h4>
<p>Por último, pero no menos importante, tenemos los costes de operación del sistema.</p>
<h4 id="caso-práctico-mediasmart-mobile-1">Caso práctico: MediaSmart Mobile</h4>
<div class="figure">
<img src="pics/mediasmart-daily-traffic.png" alt="Tráfico diario en MediaSmart Mobile" /><p class="caption">Tráfico diario en MediaSmart Mobile</p>
</div>
<p>En MediaSmart el tráfico nocturno solía ser menos de una cuarta parte del pico diario: en la gráfica se aprecia un mínimo de 2.5 millones de peticiones por minuto, frente a casi 7 millones en el pico diario (alrededor de las 8 de la tarde). Nota: Amazon AWS mide las peticiones <em>por minuto</em>, en lugar de las peticiones <em>por segundo</em> de las que hablábamos arriba. 6M por minuto equivale a 100 krps.</p>
<p>Mantener arrancados los mismos servidores todo el día suponía desperdiciar gran parte de la capacidad, y como en Amazon se paga por hora de servidor, los costes eran astronómicos. Es esencial poder usar un número variable de servidores, y eso nos obliga a tener un balanceador de carga que pueda admitir nuevas instancias dinámicamente.</p>
<h3 id="velocidad-de-migración">Velocidad de migración</h3>
<p>La velocidad a la que somos capaces de migrar de una arquitectura a otra es crítica. Demasiado lento, y no seremos capaces de absorber un tráfico creciente de peticiones; demasiado rápido, y nuestro sistema estará caído todo el tiempo.</p>
<h3 id="migraciones-de-base-de-datos">Migraciones de base de datos</h3>
<p>Las migraciones de una base de datos a otra son muy importantes al escalar un sistema.</p>
<p>Cada base de datos tiene varias características que la hacen adecuada en ciertas situaciones, y que la descartan en otras. Entre ellas:</p>
<ul>
<li>Rango operativo: ¿cuántas peticiones por segundo admite?</li>
<li>Elementos funcionales: ¿qué tipos de datos permite guardar? ¿Qué tipo de consultas se pueden hacer?</li>
<li>Tiempo de respuesta: ¿cuántos milisegundos tarda en servir cada petición?</li>
<li>Condiciones de operación: ¿cuántos servidores (y de qué tipo) necesita como mínimo? ¿Hasta cuántos escala?</li>
</ul>
<p>Durante mucho tiempo se trabajó bajo el paradigma de &quot;la base de datos perfecta&quot;, intentando que un mismo programa escalara de cero (dispositivos limitados como móviles) a infinito (un cluster con tantos servidores como queramos). Con la llegada de las bases de datos NoSQL pudimos asistir a una explosión evolutiva de tipos de bases de datos diferentes: en memoria o en cluster; clave-valor o con estructuras complejas; que admiten SQL y que no; etcétera. Cada tipo es adecuado para unas condiciones operativas diferentes, y tienen costes asociados muy distintos.</p>
<p>Además, los cambios de base de datos son ejemplos perfectos del tipo de migraciones que estamos estudiando. Así que en la sección de estrategias vamos a abusar de ellos para ilustrar cada técnica de migración.</p>
<h2 id="la-arquitectura-fluida">La arquitectura fluida</h2>
<p>¿Cuál es la solución? Nuestra humilde sugerencia es mantener la arquitectura del sistema fluida, sin tomar decisiones que comprometan su integridad. Al oir esto un arquitecto de los de verdad, de los que juntan piedras, seguramente tendría problemas para contener la risa. ¿Cómo se pueden cambiar las vigas maestras de un edificio?</p>
<p>Los ingenieros de software tenemos una gran ventaja: no trabajamos con el mundo real, sino con software, que es infinitamente moldeable.</p>
<p>Si encontramos restricciones en esta maleabilidad suele ser porque alguien no ha hecho bien su trabajo. Subiendo de nivel paulatinamente, encontramos cosas como:</p>
<ul>
<li>código duplicado, donde hay que modificar varios trozos de código para cambiar cualquier cosa, dificultando los cambios;</li>
<li>dependencias cruzadas, que hacen que un cambio en una parte tenga efectos colaterales en partes no relacionadas;</li>
<li>drivers imbricados en múltiples secciones del código, que dificultan migrar bases de datos u otros componentes similares.</li>
</ul>
<p>Vamos a centrarnos en las restricciones que nos dificultan una migración.</p>
<h3 id="reversibilidad-y-termodinámica">Reversibilidad y termodinámica</h3>
<p>En este punto vamos a tomar un desvío que nos llevará de viaje a la intemporal tierra de la termodinámica.</p>
<p>Seguro que has oído hablar de &quot;entropía&quot;: es un término muy popular entre los divulgadores científicos, que a menudo lo corrompen asignándole significados corrientes como &quot;desorden&quot;, &quot;irregularidad&quot; y similares. Es probable que no te sorprenda que la entropía tiene una definición muy precisa, o más bien varias definiciones equivalentes.</p>
<p>No es sencillo calcular la entropía de un sistema, y menos todavía medir los flujos de entropía que ocurren mientras evoluciona.</p>
<p>Por suerte, podemos tomar un atajo: un sistema reversible es, por definición, el que consigue que la entropía se mantenga en el mínimo posible. No por casualidad también es el más eficiente. Y además es muy fácil saber cuándo un sistema es reversible: cuando está en todo momento en equilibrio.</p>
<p>En 2012 exploré en <a href="../2012/reversible-engineering-part-1.html">estos</a> <a href="../2012/reversible-engineering-part-2.html">tres</a> <a href="../2012/reversible-engineering-part-3.html">artículos</a> (en inglés) una idea similar a la que he desarrollado aquí: la ingeniería reversible, o cómo trabajar siempre cerca del equilibrio. Las ideas clave son: no malgastar energía, ir lo más despacio que sea posible, y evitar turbulencias.</p>
<p>En resumen, podemos considerar reversible un sistema que puede invertirse sin consumir energía extra. Al mismo tiempo, si revertir el funcionamiento del sistema requiere energía extra, entonces el sistema no es reversible.</p>
<h3 id="migraciones">Migraciones</h3>
<p>Para realizar un cambio de una arquitectura a otra, normalmente tenemos que realizar un cambio, sea de máquinas, de programas, de código o de datos. Si las migraciones son fluidas, es decir que pasan de un estado a otro suavemente y sin turbulencias, entonces podremos considerar que tenemos una arquitectura que fluye entre un estado y otro. Las migraciones son claramente cruciales para nuestro objetivo de tener una arquitectura fluida.</p>
<h4 id="migraciones-de-máquinas">Migraciones de máquinas</h4>
<p>Normalmente cambiar de máquinas no se considera un asunto de arquitectura. Pero si miramos más allá del hierro, a menudo nos encontramos con un sistema operativo más moderno (o incluso distinto), o nuevas capacidades que requieren de cambios en el código (como los servidores multicore que nos invadieron hace un par de décadas).</p>
<h4 id="migraciones-de-programas">Migraciones de programas</h4>
<h4 id="migraciones-de-código">Migraciones de código</h4>
<p>Cuando el código está bajo nuestro control.</p>
<h4 id="migraciones-de-datos">Migraciones de datos</h4>
<h1 id="estrategias-de-migración">Estrategias de migración</h1>
<p>Llegamos ahora a la parte principal del artículo: el catálogo de estrategias. Vamos a describir varias técnicas que se pueden usar para realizar una migración, de las más bruscas a las que son completamente reversibles.</p>
<p>Todas las estrategias que vamos a describir están probadas en combate. Intentaremos ilustrar cada estrategia con un caso práctico, aunque curiosamente no es fácil encontrar publicaciones sobre migraciones. Por ello para la mayoría de ellas tendremos que recurrir a ejemplos internos de MediaSmart Mobile.</p>
<p>Aunque la mayoría de los ejemplos son de migraciones de bases de datos, las estrategias pueden usarse igualmente para cualquier migración, sea de código, de datos o de infraestructura. Las bases de datos son un ejemplo prototípico de arquitectura cliente/servidor, así que nos dan un marco de referencia bastante sólido sobre el que analizar cada estrategia.</p>
<p>La lista no es exhaustiva: seguramente el lector pueda imaginar algunas estrategias adicionales y perfectamente útiles. Puedes compartirlas al final del artículo.</p>
<p>Ilustraremos las estrategias relevantes con ejemplos de código de Node.js, muy apropiado para migraciones reversibles.</p>
<h2 id="quieres-decir-patrones">¿Quieres decir &quot;patrones&quot;?</h2>
<p>Tras el gran éxito del libro de Gamma <em>et al</em>, <em>Design Patterns</em>, la palabra &quot;patrón&quot; se usa (y se abusa) a menudo en el diseño de sistemas. Los patrones vienen a ser piezas que se deben usar cada una en su situación correspondiente. En nuestro caso, ante una migración podemos usar varias de las técnicas que vamos a describir, a nuestra elección.</p>
<p>Los elementos de juicio que usaremos para decidirnos por una o por otra son precisamente lo fluida que queramos que sea la migración, no la funcionalidad que queremos conseguir (que es siempre la misma). De ahí que prefiramos en nuestro caso el término &quot;estrategia&quot;, además de no estar viciado por el uso previo.</p>
<h2 id="catálogo-de-estrategias-de-servidor">Catálogo de estrategias de servidor</h2>
<p>En esta primera categoría tenemos estrategias que se implementan puramente en el servidor, sin tener que modificar el cliente salvo para reconfigurarlo.</p>
<h3 id="parar-y-arrancar">Parar y arrancar</h3>
<div class="figure">
<img src="pics/stop-migrate.png" alt="Stop and migrate" /><p class="caption">Stop and migrate</p>
</div>
<p>Ésta es la migración de toda la vida:</p>
<ul>
<li>se para el sistema,</li>
<li>se copia la base de datos antigua a la nueva (copia en frío),</li>
<li>se reconfiguran los clientes para que apunten a la nueva,</li>
<li>y se vuelve a arrancar el sistema.</li>
</ul>
<p>Esta estrategia requiere dejar de dar servicio, con lo que no es apropiada para situaciones de alta disponibilidad. Claramente no es realmente reversible, y además es un poco chapucera.</p>
<h4 id="código-de-ejemplo">Código de ejemplo</h4>
<p>El código de servidor es muy sencillo. Primero tenemos un fichero <code>settings.js</code> que almacena la configuración:</p>
<pre><code>module.exports = {
    redisAddress: &#39;redis.mydomain.com&#39;,
};</code></pre>
<p>El fichero intermedio <code>db.js</code> define las bases de datos que usaremos, en este caso <code>current</code>:</p>
<pre><code>var settings = require(&#39;./settings.js&#39;);
module.exports = {
    current: new RedisAdapter(settings.redisAddress),
};</code></pre>
<p>Finalmente, en cada sitio donde usemos la base de datos accederemos a<code>db.current</code>:</p>
<pre><code>var db = require(&#39;./db.js&#39;);
db.current.get(key, function(error, result) {
    ...
});</code></pre>
<h4 id="caso-práctico">Caso práctico</h4>
<p>El primer caso práctico que vamos a ver no es precisamente una migración de base de datos. En MediaSmart Mobile necesitábamos migrar nuestra infraestructura en la nube de Amazon (AWS), de una conexión no segura a la VPC (<em>Virtual Private Cloud</em>).</p>
<p>El 3 de marzo de 2015 realizamos la migración: primero creamos una réplica de todos los servidores en la VPC. A continuación paramos los servidores originales, y copiamos los datos a la VPC. Luego arrancamos los nuevos sevidores, y apuntamos el servidor DNS hacia ellos. Tras algunas horas de <em>downtime</em> estábamos arriba otra vez.</p>
<p>El día 5 de marzo nos reportaron problemas en producción, por lo que tuvimos que deshacer la migración. Por fortuna habíamos mantenido las instancias antiguas, así que fue cuestión de parar, volver a copiar los datos y arrancar otra vez. Por ironías de la vida, el problema no se resolvió con esta migración inversa, por lo que dedujimos que tenía otra causa. Curiosamente, una vez que nos quitamos de enmedio la causa más obvia (la migración), el problema real se hizo evidente de inmediato y no tenía nada que ver, sino que venía causado por un despliegue anterior.</p>
<p>El día 11 de marzo probamos de nuevo con la misma técnica, y de nuevo tras varias horas de <em>downtime</em> la migración estaba hecha. Como operamos en dos regiones de AWS, todavía teníamos que migrar la segunda región, cosa que hicimos el día 13 de marzo (viernes). Porque total, viernes 13: ¿qué podía salir mal? Y no somos supersticiosos.</p>
<p>La moraleja es algo poco intuitivo: el mayor problema de hacer una migración es muchas veces que nos impide pensar claramente sobre los fallos del sistema, ya que nos fijaremos más en los posibles efectos colaterales que en el problema que tenemos delante. Por eso es importante tener una estrategia de migración inversa que devuelva el sistema a su estado inicial.</p>
<p>Y, una vez que tenemos la estrategia inversa, también es importante (y de nuevo contraintuitivo) que lo mejor es no realizar la migración inversa, sino buscar las causas profundas de los problemas.</p>
<h3 id="versión-de-sólo-lectura">Versión de sólo lectura</h3>
<div class="figure">
<img src="pics/read-only-version.png" alt="Read-only version" /><p class="caption">Read-only version</p>
</div>
<p>Ahora veremos una estrategia ligeramente más sofisticada. Los pasos son:</p>
<ul>
<li>pasar a un modo de sólo lectura,</li>
<li>hacer una copia en caliente (mientras el sistema está andando),</li>
<li>cambiar a la nueva base de datos,</li>
<li>y volver al modo de lectura/escritura.</li>
</ul>
<p>Mientras el sistema está en sólo lectura, se puede acceder a los datos pero no modificarlos. De esta forma nos aseguramos de que se pueda hacer la copia en caliente: como los datos no cambian, o tenemos que preocuparnos de que se la copia esté desfasada al terminar.</p>
<p>Esto suele ser bastante mejor que una parada completa. Pero no siempre es admisible: ciertos sistemas tienen que estar recogiendo datos nuevos constantemente, así que dejarlos en sólo lectura no es posible.</p>
<p>Otro problema es que una copia en caliente puede tardar bastante más que en frío, debido a los accesos constantes.</p>
<p>La migración inversa es fácil: volver a sólo lectura, copiar y migrar en sentido contrario. Al mismo tiempo, podemos ver que una migración de este tipo no es realmente reversible, ya que requiere trabajo extra revertirlas.</p>
<h4 id="caso-práctico-1">Caso práctico</h4>
<h3 id="sincronización">Sincronización</h3>
<div class="figure">
<img src="pics/sync.png" alt="Synchronization" /><p class="caption">Synchronization</p>
</div>
<p>Supongamos de nuevo que tenemos dos bases de datos, la antigua y la nueva. Los pasos para hacer la sincronización son:</p>
<ul>
<li>hacer una copia en caliente de la antigua a la nueva,</li>
<li>sincronizar todas las escrituras de la antigua a la nueva,</li>
<li>y finalmente cambiar los accesos a la nueva.</li>
</ul>
<p>La sincronización se hace en este caso mediante un mecanismo de servidor, que recoge todas las escrituras y pasarlas a otro sistema. No siempre es posible hacerlo: a veces la carga en el sistema antiguo es demasiado grande, o puede que no haya forma de fechar los cambios para extraer sólo los últimos, lo que haría la sincronización total demasiado costosa.</p>
<p>En el lado positivo, los usuarios no notarán ningún <em>downtime</em> al acceder al sistema.</p>
<p>Además, la estrategia inversa es trivial: sólo hay que volver a cambiar los accesos a la base de datos antigua, mientras no desconectemos el mecanismo de sincronización. Si ya no estamos sincronizando los cambios, la migración inversa requiere sincronizar los datos en el sentido contrario. La sincronización bidireccional a menudo es demasiado costosa como para ser práctica. Por tanto, hay que tener cuidado de seguir sincronizando hasta que estemos seguros de que la migración ha sido exitosa y no vamos a querer revertirla nunca.</p>
<h4 id="caso-práctico-2">Caso práctico</h4>
<p>MediaSmart daystats</p>
<h3 id="copia-doble">Copia doble</h3>
<div class="figure">
<img src="pics/double-copy.png" alt="Double copy" /><p class="caption">Double copy</p>
</div>
<h4 id="caso-práctico-3">Caso práctico</h4>
<p>MediaSmart perfiles</p>
<h2 id="catálogo-de-estrategias-en-cliente">Catálogo de estrategias en cliente</h2>
<h3 id="decorador">Decorador</h3>
<h4 id="caso-práctico-4">Caso práctico</h4>
<h3 id="consulta-dual">Consulta dual</h3>
<div class="figure">
<img src="pics/dual-lookup.png" alt="Dual lookup" /><p class="caption">Dual lookup</p>
</div>
<h4 id="caso-práctico-5">Caso práctico</h4>
<h3 id="escritura-dual">Escritura dual</h3>
<div class="figure">
<img src="pics/dual-write.png" alt="Dual write" /><p class="caption">Dual write</p>
</div>
<h4 id="caso-práctico-6">Caso práctico</h4>
<h3 id="paso-temporizado">Paso temporizado</h3>
<div class="figure">
<img src="pics/timed-rollover.png" alt="Timed rollover" /><p class="caption">Timed rollover</p>
</div>
<h4 id="caso-práctico-7">Caso práctico</h4>
<p>MediaSmart stats aggregates</p>
<h3 id="conversión-in-situ">Conversión <em>in situ</em></h3>
<div class="figure">
<img src="pics/in-place.png" alt="In-place conversion" /><p class="caption">In-place conversion</p>
</div>
<p>En esta conversión, no hay</p>
<h4 id="caso-práctico-8">Caso práctico</h4>
<h2 id="catálogo-de-estrategias-en-broker">Catálogo de estrategias en broker</h2>
<h3 id="acceso-mediante-proxy">Acceso mediante proxy</h3>
<div class="figure">
<img src="pics/proxied-access.png" alt="Proxied access" /><p class="caption">Proxied access</p>
</div>
<h4 id="caso-práctico-9">Caso práctico</h4>
<p>Instagram</p>
<h3 id="escritura-en-cola">Escritura en cola</h3>
<div class="figure">
<img src="pics/queued-write.png" alt="Queued write" /><p class="caption">Queued write</p>
</div>
<h4 id="caso-práctico-10">Caso práctico</h4>
<h1 id="vamos-terminando">Vamos terminando</h1>
<h2 id="migración-de-cualquier-tipo">Migración de cualquier tipo</h2>
<div class="figure">
<img src="pics/all.png" alt="All strategies" /><p class="caption">All strategies</p>
</div>
<p>Todas las estrategias que hemos visto son útiles no sólo para migraciones de base de datos.</p>
<h2 id="el-equilibrio-inestable">El equilibrio inestable</h2>
<p>Un sistema que fluye se mantiene en equilibrio, pero no es necesariamente un equilibrio estable.</p>
<p>Veamos un ejemplo sacado de una ingeniería completamente diferente: la aerodinámica. Los <a href="http://aviation.stackexchange.com/a/8061/12166">aviones supersónicos</a> tienen que funcionar en dos regímenes completamente diferentes: primero tienen que volar en modo subsónico, y una vez que alcanzan la velocidad del sonido pasan al modo supersónico. Esto causa un problema: el centro de gravedad está por detrás del punto neutro, lo que hace que el vuelo sea inestable. La única forma de mantenerlos en el aire sin que se desintegren es corregir la trayectoria con un ordenador de a bordo, sin el cual el vuelo sería completamente imposible.</p>
<p>(Los aviones acrobáticos también son inherentemente inestables, lo que los hace más manejables, pero al volar a menos velocidad es posible que un piloto lo controle.)</p>
<p>En nuestro caso, un sistema que fluye demasiado despacio se vuelve también difícil de manejar, lo que podemos contrarrestar aumentando la velocidad del cambio. Pero en este caso el sistema se vuelve inestable, y hay que controlarlo para que los fallos que van surgiendo no se acumulen.</p>
<p>La velocidad de crucero óptima es la que nos permite realizar cambios al sistema de la forma más rápida, sin comprometer la integridad del sistema.</p>
<h2 id="sigue-fluyendo">Sigue fluyendo</h2>
<p>Entre tanta migración, no hay que perder de vista el objetivo final: tener una arquitectura flexible, que puede adaptarse a las nuevas circunstancias rápidamente.</p>
								</div>
							</section>
							<section id="last">
								<div class="container">
									<p>
									Publicado originalmente en TodoJS el 2015-.
									</p>
									<p>
									Back to the <a href="../index.html">index</a>.
									</p>
								</div>
							</section>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<ul class="copyright">
								<li>&copy; Alex Fernández. Distributed under the <a href="https://opensource.org/licenses/MIT">MIT license</a>.</li>
								<li>Original design: <a href="http://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</section>

			</div>
	</body>
</html>
