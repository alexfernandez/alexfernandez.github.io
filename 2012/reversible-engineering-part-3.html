<!DOCTYPE HTML>
<!--
	Read Only by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)

	Modified by Alex Fern√°ndez
	https://pinchito.es/ | @pinchito
-->
<html>
	<head>
		<title>Reversible Engineering, Part 3: Management</title>
		<meta charset="utf-8" />
		<meta name="description" content="Reversible Engineering, Part 3:
Management ‚Äî " />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@pinchito" />
		<meta name="twitter:title" content="Reversible Engineering, Part 3:
Management ‚Äî " />
		<meta name="twitter:description" content="" />
		<meta name="twitter:image" content="" />
		<meta property="og:title" content="Reversible Engineering, Part 3:
Management ‚Äî " />
		<meta property="og:type" content="website" />
		<meta property="og:description" content="" />
		<meta property="og:image" content="" />
		<meta property="og:url" content="https://pinchito.es/2012/reversible-engineering-part-3" />
		<link rel="stylesheet" href="/css/main.css" />
		<link rel="canonical" href="https://pinchito.es/2012/reversible-engineering-part-3" />
		<link rel="shortcut icon" href="/favicon.png" type="image/png" />
		<!--[if lte IE 8]><link rel="stylesheet" href="/css/ie8.css" /><![endif]-->
	</head>
	<body>

		<!-- Header -->
			<section id="header">
				<header>
					<p class="home"><a class="home" href="/">pinchito.es</a></p>
					<p>
					<a href="/about">about</a>
					<br/>
					<a href="/cv">CV</a>
					<br/>
					<a href="/rss.xml">
						<svg aria-hidden="true" class="rss-icon" width="18" height="18" viewBox="0 0 18 18"><path d="M3 1a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2zm0 1.5c6.9 0 12.5 5.6 12.5 12.5H13C13 9.55 8.45 5 3 5zm0 5c4.09 0 7.5 3.41 7.5 7.5H8c0-2.72-2.28-5-5-5zm0 5c1.36 0 2.5 1.14 2.5 2.5H3z"></path></svg>
						RSS feed</a>
					</p>
					<p>
					<a id="follower" href="https://twitter.com/intent/follow?screen_name=pinchito" target="_blank"><i id="birdie"></i>@pinchito</a>
					<br />
					<a rel="me" href="https://mastodon.social/@pinchito" target="_blank">üêò @pinchito@mastodon.social</a>
					<br/>
					<a href="https://github.com/alexfernandez" aria-label="Follow @alexfernandez on GitHub">alexfernandez @ GitHub</a>
					</p>
					<p>
					This site is cookie free! No tracking is done on your browser.
					</p>
					<a href="https://librecounter.org/referer/show" target="_blank">
					<img src="https://librecounter.org/counter.svg" referrerPolicy="unsafe-url">
					</a>
				</header>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<section id="zero">
							<p class="home"><a class="home" href="/">pinchito.es</a></p>
						</section>

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h1>Reversible Engineering, Part 3: Management</h1>
										<p><p>
									</header>
																				<figure>
<img src="pics/reversible-engineering-part-3.jpg" title="Canalside"
alt="Photo credit: Steve Heron." />
<figcaption aria-hidden="true">Photo credit: <a
href="https://www.flickr.com/photos/sbh/6774004978/in/photostream">Steve
Heron.</a></figcaption>
</figure>
<p>In the <a href="reversible-engineering-part-1">first part</a> of this
series we looked into reversible processes as a way of minimizing
engineering complexity; and explored how to approach software
development near reversibility. In the <a
href="reversible-engineering-part-2">second part</a> we then applied
this principle to DevOps, and derived explanations for a lot of modern
practices.</p>
<p>In this last installment we will try to tame that fearful beast in
the minds of most engineers: management, or how to organize the work of
other people. Let us now take a look at how management can benefit from
reversibility.</p>
<h2 id="that-pesky-complexity-again">That Pesky Complexity Again</h2>
<p>A manager is expected to keep things organized and in good order.
Perhaps the hardest thing to manage is complexity: check your local
documentation repositories for easy examples. Where is the internal
documentation stored in your company? Is it easy to use? Can you find
things quickly when needed, or do you keep a lot of bookmarks which in
turn have to be organized?</p>
<p>Organizing documents is not an unsolvable problem: search engines
have made it easy to find information on the vast seas of the wild
internet. How come a generic search engine can find a page almost
anywhere, but a specialized corporate tool can get lost in a few
thousand documents? The approaches are vastly different: organization is
quite different from discovery. As information is added to a system <a
href="http://www.science20.com/hammock_physicist/what_entropy-89730">its
entropy increases</a> and it becomes harder to keep any indexes
updated.</p>
<p>Here is where reversibility can help us. If our processes are almost
reversible, which means that adding information to our system is as easy
as removing it, we are guaranteed by the Second Law that entropy is kept
at a minimum. The traditional view of thermodynamics is that a
reversible process is most energy-efficient, and that any turbulences
cause efficiency losses. The information theory approach tells us that
in a reversible process complexity is reduced as much as possible.</p>
<p>A trivial example is the undo function found in many software
packages: when any action is easy to undo then it becomes easier to
perform any desired changes. Otherwise the user has to keep back up
copies of any intermediate steps to avoid losing work; experimentation
becomes harder and in the end the results are much less efficient than
they could be.</p>
<p>We can strive for reversibility, or alternatively aim at a steady
state near the point of equilibrium. Any instabilities in a system will
cause entropy to increase faster, and it will require more information
to be described than should be necessary. As a consequence new recruits
will need to know more things before they are productive, changes will
take longer and the system will become harder to evolve. Not what
managers usually want of their projects.</p>
<p>Reversibility shines a new light on the common management recipe:
‚Äúavoid heroic efforts, establish a repeatable process‚Äù. The former are
by their very nature irreversible: nobody asks heroes to undo their
heroic deeds. The latter is close to the steady state, since a process
that can be repeated as often as needed cannot end too far from where it
started.</p>
<p>Let us now see how we can strive to keep our processes near
reversibility from the point of view of pure management.</p>
<h2 id="reversible-decisions">Reversible Decisions</h2>
<p>Probably the most apparent feature of management is making decisions.
The manager is the boss, and as such is expected to decide on future
courses of actions. Decisions should of course be firmly maintained once
taken. Or should they not?</p>
<p>In his piece <a href="http://lwn.net/Articles/105375/">Linux kernel
management style</a>, Linus Torvalds (of Linux fame) states:</p>
<blockquote>
<p>Thus the key to avoiding big decisions becomes to just avoiding to do
things that can‚Äôt be undone. Don‚Äôt get ushered into a corner from which
you cannot escape. A cornered rat may be dangerous - a cornered manager
is just pitiful.</p>
</blockquote>
<p>Observe how the emphasis is in avoiding irreversible decisions. Of
course decisions can never be perfectly reversible: there will always be
a cost associated with undoing some work that has been done. But in the
presence of several valid alternatives the best course of action is
always to leave your options open, and to be able to backtrack
later.</p>
<p>Now look at your typical project management tool: what do you see?
With all probability it will be dominated by a Gantt diagram full of
tasks, some marked as ‚Äúdone‚Äù and others marked with a percentage of
completeness. If you are lucky you will perhaps just see a set of
milestones, each marked as ‚Äúdone‚Äù or ‚Äúundone‚Äù. Things can take longer
than foreseen, but once a task is done nobody expects it to be reopened;
in this view of the world a project is a mass of irreversible tasks. How
can the engineers redo something which isn‚Äôt well finished? Answer: they
cannot dedicate any more time to a closed task without great pains,
often in secret. As a result, tasks poorly executed will probably burden
the project further on, either in time or in subpar results.</p>
<p>Time-boxed releases are much closer to reversibility: release
versions at regular intervals, and add features as time allows. The
adoption of regular releases in many software projects is often touted
as a success of agile methodologies, but that is hardly an explanation
of why time-boxed development works. In fact, agile methodologies
advocate for cycles of about one to three weeks, while free software
seems to have adopted periods of a few months. Perhaps there is a common
factor in both approaches?</p>
<p>We have met cycles before in this series: they are an easy way to
reach the steady state. In the typical time-boxed process tasks are not
irreversibly closed: subsystems are worked upon as part of the
continuous improvement of the global system, and therefore they can be
revisited as needed. Similarly the team does not change work radically
from one task to the next, but they are assigned changes in a more or
less steady flow and they just switch from one to the other. Any change
can be reopened at any time, without cost. Another triumph of
reversibility!</p>
<h2 id="dealing-with-irreversibilities">Dealing with
Irreversibilities</h2>
<p>A project moving forward, even with time-boxed releases, is sure to
meet irreversible points such as go/no-go criteria, public releases, and
changes of staff. Marketing campaigns have to be devised and executed,
staff must be engaged and in general money must be spent wisely. How can
our poor engineer-turned-manager deal with those irreversible
events?</p>
<p>Instead of dealing with a constant cascade of irreversibilities, it
is better to group them into specific points, and advertise them as such
within the organization. People will be prepared for them; meanwhile
they don‚Äôt need to waste all their energies into endless irreversible
checkpoints. Once each significant milestone is reached an appropriate
decision can be taken, and hopefully any other options can be left
open.</p>
<p>Staffing a project is an entirely different matter. Instead of
grouping irreversible events, the best way to deal with staffing levels
is to change them gradually. Losing half the people in a project is a
good way to doom it; but so is doubling the team in a short period. Here
the usual recipe of reversible processes, give them time to cook slowly,
is your best ally.</p>
<p>Another option is to keep a flexible workforce: have people available
to work on stuff at short notice. Of course, the specific systems worked
upon must already be very simple so that the newcomers get up to speed
quickly. This is hard to do in an IT project, but it can be attained
using standard interfaces: a Linux sysadmin will probably get up to
speed quickly in any new Linux system, provided there are not too many
idiosyncrasies. The advice then becomes: keep standard parts standard,
and keep your workforce flexible. If this can be done if only in a few
parts of the system, it will be a net gain.</p>
<h2 id="management-as-code">Management as Code</h2>
<p>What, you seriously thought that we were going to keep this at the
‚Äúpure management‚Äù level, without talking about code? Got you! Even when
wearing the manager hat we are still engineers: just as DevOps is based
in the principle of ‚Äúinfrastructure as code‚Äù, ideally we will be able to
do the same with management. First and foremost we try to solve our
problems, then we embed our solutions into code and run it as often as
necessary. The result is management applications, also called management
information systems and many other boring names.</p>
<p>The basic elements of any management application are four operations
which go by the acronym <a
href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>:
create, read, update and delete. Note how they behave with respect to
reversibility: the read operation does not affect reversibility, create
and delete are the opposite of each other, and update is its own
opposite (an update is reverted by another update). From our point of
view it is important to have always the reverse of any operation, from
the lowest level of atomic modifications to high level operations.</p>
<p>To be really reversible, any management system needs to keep a
history of all past actions, and be able to undo them at will. Ideally
we should be able to bring the system back to its state at any arbitrary
point in the past, as we saw with <a
href="reversible-engineering-part-2">code repositories</a>. At the very
least we have to store extra info along with the raw data, so that we
can reconstruct the history of modifications and revert them at will.
Then we have to organize our modifications and undo them in groups that
represent the high level organization of data.</p>
<p>Synchronization is a particular thorny issue. When there are several
copies of each piece of data it becomes harder to update any one of
them, as there is a high probability that we will forget one of them;
there is an added effort to resynchronize any duplicate piece of
information. The effort required to backtrack any such change also
grows: the system must know that two or more changes always go together,
and if any one is reverted the rest must also be undone.</p>
<p>For many years the technical answer has been to avoid duplicate data;
normalized databases are the canonical example, where every piece of
data is stored once and only once, and they lie at the core of most
management systems. Unfortunately this approach carries with it many
disadvantages:</p>
<ul>
<li>Redundant data is not always duplicate: e.g.¬†the number of user
accesses can be found adding together accesses to every page, but
sometimes total and partial access counts must be kept separately. The
usual trick is to do both changes atomically, as a single step that can
be completed or aborted; but no thought is usually given to reverting
the change as a whole.</li>
<li>Performance is penalized when accessing normalized data: sometimes
many unrelated tables have to be queried to return a single item.
Denormalization allows a database to keep related data together for easy
access.</li>
<li>Following pure normalization rules blindly can lead to databases
with many thousands of tables which are hard to follow.</li>
<li>Reality is stubborn: the double-entry accounting system was invented
to avoid making mistakes.</li>
</ul>
<p>The new breed of NoSQL databases tackle the same set of problems by
freeing schemas and allowing denormalized data to live happily in the
system. Avoiding irreversible schema changes is good, as we saw in <a
href="reversible-engineering-part-2">part two</a>, but these newfangled
databases don‚Äôt go far enough: they don‚Äôt give so much thought to
keeping the full history of the data as it is manipulated.</p>
<p>An ideal management system should not only keep information about all
the changes in the system, but also keep related changes together and do
or undo them as a whole. Having several management systems synchronized
is left as an exercise for the reader; ample margin should be found at
both sides to write a solution should they wish to <a
href="http://en.wikipedia.org/wiki/Fermat&#39;s_Last_Theorem">write the
solution there</a>.</p>
<h2 id="informative-complexities">Informative Complexities</h2>
<p>In the previous section we have seen how we need to store more
information to reduce the entropy of a system. If you have been paying
attention you will now be wondering:</p>
<blockquote>
<p>Now wait a minute, mister! You told us that more information means
more complexity! How come now we have to store more things to reduce
complexity?</p>
</blockquote>
<p>It is actually a very good point, and to answer it we have to delve a
bit further into what entropy really means in information theory. In
fact we have been playing a bit loosely with entropy here. What <a
href="http://en.wikipedia.org/wiki/Entropy_(information_theory)">Shannon
entropy</a> really quantifies is how much information we are missing
about a system to fully describe it, not how much we already have. As we
add complexity to a system we strive to keep all of it under bounds.
Think about the amount of information that a new recruit needs to know
about a system before being 100% productive: how many quirks are there
lurking in the shadows, waiting to bite them? Is it all stored together
and easily accessible, or will our unlucky newbie have to ask lots of
people to gather the knowledge?</p>
<p>The Second Law of Thermodynamics tells us that our knowledge of any
system will never be perfect, and it will get worse with time; as the
system evolves we will lose more and more bits of it. If we are not
careful then there will be so many pieces lost that it will be simply
impossible to make any further changes. On the other hand, a reversible
process ensures that total entropy does not increase, and therefore all
new pieces will be fully described and accounted for as they are
added.</p>
<p>When all the history is stored in the system the complexity of the
total system is decreased, since we may revert any change at will. The
system is fully described within itself, and that is complexity we save
ourselves. The easier it is to access history information, the closer to
reversibility we will be, and the smoother our projects will flow.</p>
								</div>
							</section>
							<section id="last">
								<div class="container">
									<p>
									Posted originally at <a
href="http://tech.moveinblue.com/post/23414460113/reversible-engineering-part-3-management">Tumblr</a>
on 2012-05-20.
									</p>
									<p>
									Back to the <a href="/">index</a>.
									</p>
								</div>
							</section>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<ul class="copyright">
								<li>
									¬© <a href="mailto:alexfernandeznpm@gmail.com">Alex Fern√°ndez</a>.
									<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
								</li>
								<li>Original design: <a href="http://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</section>

			</div>
	</body>
</html>
